/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: proto/gtfs-realtime.proto */

#ifndef PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _TransitRealtime__FeedMessage TransitRealtime__FeedMessage;
typedef struct _TransitRealtime__FeedHeader TransitRealtime__FeedHeader;
typedef struct _TransitRealtime__FeedEntity TransitRealtime__FeedEntity;
typedef struct _TransitRealtime__TripUpdate TransitRealtime__TripUpdate;
typedef struct _TransitRealtime__TripUpdate__StopTimeEvent TransitRealtime__TripUpdate__StopTimeEvent;
typedef struct _TransitRealtime__TripUpdate__StopTimeUpdate TransitRealtime__TripUpdate__StopTimeUpdate;
typedef struct _TransitRealtime__VehiclePosition TransitRealtime__VehiclePosition;
typedef struct _TransitRealtime__Alert TransitRealtime__Alert;
typedef struct _TransitRealtime__TimeRange TransitRealtime__TimeRange;
typedef struct _TransitRealtime__Position TransitRealtime__Position;
typedef struct _TransitRealtime__TripDescriptor TransitRealtime__TripDescriptor;
typedef struct _TransitRealtime__VehicleDescriptor TransitRealtime__VehicleDescriptor;
typedef struct _TransitRealtime__EntitySelector TransitRealtime__EntitySelector;
typedef struct _TransitRealtime__TranslatedString TransitRealtime__TranslatedString;
typedef struct _TransitRealtime__TranslatedString__Translation TransitRealtime__TranslatedString__Translation;


/* --- enums --- */

/*
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 */
typedef enum _TransitRealtime__FeedHeader__Incrementality {
  TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__FULL_DATASET = 0,
  TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__DIFFERENTIAL = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY)
} TransitRealtime__FeedHeader__Incrementality;
/*
 * The relation between this StopTime and the static schedule.
 */
typedef enum _TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship {
  /*
   * The vehicle is proceeding in accordance with its static schedule of
   * stops, although not necessarily according to the times of the schedule.
   * At least one of arrival and departure must be provided. If the schedule
   * for this stop contains both arrival and departure times then so must
   * this update.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SCHEDULED = 0,
  /*
   * The stop is skipped, i.e., the vehicle will not stop at this stop.
   * Arrival and departure are optional.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SKIPPED = 1,
  /*
   * No data is given for this stop. The main intention for this value is to
   * give the predictions only for part of a trip, i.e., if the last update
   * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
   * stops in the trip are considered to be unspecified as well.
   * Neither arrival nor departure should be supplied.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__NO_DATA = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP)
} TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship;
typedef enum _TransitRealtime__VehiclePosition__VehicleStopStatus {
  /*
   * The vehicle is just about to arrive at the stop (on a stop
   * display, the vehicle symbol typically flashes).
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__INCOMING_AT = 0,
  /*
   * The vehicle is standing at the stop.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__STOPPED_AT = 1,
  /*
   * The vehicle has departed and is in transit to the next stop.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS)
} TransitRealtime__VehiclePosition__VehicleStopStatus;
/*
 * Congestion level that is affecting this vehicle.
 */
typedef enum _TransitRealtime__VehiclePosition__CongestionLevel {
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL = 0,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__RUNNING_SMOOTHLY = 1,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__STOP_AND_GO = 2,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__CONGESTION = 3,
  /*
   * People leaving their cars.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__SEVERE_CONGESTION = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL)
} TransitRealtime__VehiclePosition__CongestionLevel;
/*
 * The degree of passenger occupancy of the vehicle. This field is still
 * experimental, and subject to change. It may be formally adopted in the
 * future.
 */
typedef enum _TransitRealtime__VehiclePosition__OccupancyStatus {
  /*
   * The vehicle is considered empty by most measures, and has few or no
   * passengers onboard, but is still accepting passengers.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY = 0,
  /*
   * The vehicle has a relatively large percentage of seats available.
   * What percentage of free seats out of the total seats available is to be
   * considered large enough to fall into this category is determined at the
   * discretion of the producer.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__MANY_SEATS_AVAILABLE = 1,
  /*
   * The vehicle has a relatively small percentage of seats available.
   * What percentage of free seats out of the total seats available is to be
   * considered small enough to fall into this category is determined at the
   * discretion of the feed producer.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__FEW_SEATS_AVAILABLE = 2,
  /*
   * The vehicle can currently accommodate only standing passengers.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__STANDING_ROOM_ONLY = 3,
  /*
   * The vehicle can currently accommodate only standing passengers
   * and has limited space for them.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__CRUSHED_STANDING_ROOM_ONLY = 4,
  /*
   * The vehicle is considered full by most measures, but may still be
   * allowing passengers to board.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__FULL = 5,
  /*
   * The vehicle is not accepting additional passengers.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__NOT_ACCEPTING_PASSENGERS = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS)
} TransitRealtime__VehiclePosition__OccupancyStatus;
/*
 * Cause of this alert.
 */
typedef enum _TransitRealtime__Alert__Cause {
  TRANSIT_REALTIME__ALERT__CAUSE__UNKNOWN_CAUSE = 1,
  /*
   * Not machine-representable.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__OTHER_CAUSE = 2,
  TRANSIT_REALTIME__ALERT__CAUSE__TECHNICAL_PROBLEM = 3,
  /*
   * Public transit agency employees stopped working.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__STRIKE = 4,
  /*
   * People are blocking the streets.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__DEMONSTRATION = 5,
  TRANSIT_REALTIME__ALERT__CAUSE__ACCIDENT = 6,
  TRANSIT_REALTIME__ALERT__CAUSE__HOLIDAY = 7,
  TRANSIT_REALTIME__ALERT__CAUSE__WEATHER = 8,
  TRANSIT_REALTIME__ALERT__CAUSE__MAINTENANCE = 9,
  TRANSIT_REALTIME__ALERT__CAUSE__CONSTRUCTION = 10,
  TRANSIT_REALTIME__ALERT__CAUSE__POLICE_ACTIVITY = 11,
  TRANSIT_REALTIME__ALERT__CAUSE__MEDICAL_EMERGENCY = 12
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__ALERT__CAUSE)
} TransitRealtime__Alert__Cause;
/*
 * What is the effect of this problem on the affected entity.
 */
typedef enum _TransitRealtime__Alert__Effect {
  TRANSIT_REALTIME__ALERT__EFFECT__NO_SERVICE = 1,
  TRANSIT_REALTIME__ALERT__EFFECT__REDUCED_SERVICE = 2,
  /*
   * We don't care about INsignificant delays: they are hard to detect, have
   * little impact on the user, and would clutter the results as they are too
   * frequent.
   */
  TRANSIT_REALTIME__ALERT__EFFECT__SIGNIFICANT_DELAYS = 3,
  TRANSIT_REALTIME__ALERT__EFFECT__DETOUR = 4,
  TRANSIT_REALTIME__ALERT__EFFECT__ADDITIONAL_SERVICE = 5,
  TRANSIT_REALTIME__ALERT__EFFECT__MODIFIED_SERVICE = 6,
  TRANSIT_REALTIME__ALERT__EFFECT__OTHER_EFFECT = 7,
  TRANSIT_REALTIME__ALERT__EFFECT__UNKNOWN_EFFECT = 8,
  TRANSIT_REALTIME__ALERT__EFFECT__STOP_MOVED = 9
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__ALERT__EFFECT)
} TransitRealtime__Alert__Effect;
/*
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 */
typedef enum _TransitRealtime__TripDescriptor__ScheduleRelationship {
  /*
   * Trip that is running in accordance with its GTFS schedule, or is close
   * enough to the scheduled trip to be associated with it.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED = 0,
  /*
   * An extra trip that was added in addition to a running schedule, for
   * example, to replace a broken vehicle or to respond to sudden passenger
   * load.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__ADDED = 1,
  /*
   * A trip that is running with no schedule associated to it, for example, if
   * there is no schedule at all.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__UNSCHEDULED = 2,
  /*
   * A trip that existed in the schedule but was removed.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__CANCELED = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP)
} TransitRealtime__TripDescriptor__ScheduleRelationship;

/* --- messages --- */

/*
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 */
struct  _TransitRealtime__FeedMessage
{
  ProtobufCMessage base;
  /*
   * Metadata about this feed and feed message.
   */
  TransitRealtime__FeedHeader *header;
  /*
   * Contents of the feed.
   */
  size_t n_entity;
  TransitRealtime__FeedEntity **entity;
};
#define TRANSIT_REALTIME__FEED_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_message__descriptor) \
    , NULL, 0,NULL }


/*
 * Metadata about a feed, included in feed messages.
 */
struct  _TransitRealtime__FeedHeader
{
  ProtobufCMessage base;
  /*
   * Version of the feed specification.
   * The current version is 2.0.
   */
  char *gtfs_realtime_version;
  protobuf_c_boolean has_incrementality;
  TransitRealtime__FeedHeader__Incrementality incrementality;
  /*
   * This timestamp identifies the moment when the content of this feed has been
   * created (in server time). In POSIX time (i.e., number of seconds since
   * January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
};
#define TRANSIT_REALTIME__FEED_HEADER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_header__descriptor) \
    , NULL, 0, TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__FULL_DATASET, 0, 0 }


/*
 * A definition (or update) of an entity in the transit feed.
 */
struct  _TransitRealtime__FeedEntity
{
  ProtobufCMessage base;
  /*
   * The ids are used only to provide incrementality support. The id should be
   * unique within a FeedMessage. Consequent FeedMessages may contain
   * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
   * FeedEntity with some id will replace the old FeedEntity with the same id
   * (or delete it - see is_deleted below).
   * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
   * feed must be specified by explicit selectors (see EntitySelector below for
   * more info).
   */
  char *id;
  /*
   * Whether this entity is to be deleted. Relevant only for incremental
   * fetches.
   */
  protobuf_c_boolean has_is_deleted;
  protobuf_c_boolean is_deleted;
  /*
   * Data about the entity itself. Exactly one of the following fields must be
   * present (unless the entity is being deleted).
   */
  TransitRealtime__TripUpdate *trip_update;
  TransitRealtime__VehiclePosition *vehicle;
  TransitRealtime__Alert *alert;
};
#define TRANSIT_REALTIME__FEED_ENTITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_entity__descriptor) \
    , NULL, 0, 0, NULL, NULL, NULL }


/*
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 */
struct  _TransitRealtime__TripUpdate__StopTimeEvent
{
  ProtobufCMessage base;
  /*
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   */
  protobuf_c_boolean has_delay;
  int32_t delay;
  /*
   * Event as absolute time.
   * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
   * UTC).
   */
  protobuf_c_boolean has_time;
  int64_t time;
  /*
   * If uncertainty is omitted, it is interpreted as unknown.
   * If the prediction is unknown or too uncertain, the delay (or time) field
   * should be empty. In such case, the uncertainty field is ignored.
   * To specify a completely certain prediction, set its uncertainty to 0.
   */
  protobuf_c_boolean has_uncertainty;
  int32_t uncertainty;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_EVENT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__stop_time_event__descriptor) \
    , 0, 0, 0, 0, 0, 0 }


/*
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 */
struct  _TransitRealtime__TripUpdate__StopTimeUpdate
{
  ProtobufCMessage base;
  /*
   * Must be the same as in stop_times.txt in the corresponding GTFS feed.
   */
  protobuf_c_boolean has_stop_sequence;
  uint32_t stop_sequence;
  /*
   * Must be the same as in stops.txt in the corresponding GTFS feed.
   */
  char *stop_id;
  TransitRealtime__TripUpdate__StopTimeEvent *arrival;
  TransitRealtime__TripUpdate__StopTimeEvent *departure;
  protobuf_c_boolean has_schedule_relationship;
  TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship schedule_relationship;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__stop_time_update__descriptor) \
    , 0, 0, NULL, NULL, NULL, 0, TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SCHEDULED }


/*
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 */
struct  _TransitRealtime__TripUpdate
{
  ProtobufCMessage base;
  /*
   * The Trip that this message applies to. There can be at most one
   * TripUpdate entity for each actual trip instance.
   * If there is none, that means there is no prediction information available.
   * It does *not* mean that the trip is progressing according to schedule.
   */
  TransitRealtime__TripDescriptor *trip;
  /*
   * Additional information on the vehicle that is serving this trip.
   */
  TransitRealtime__VehicleDescriptor *vehicle;
  /*
   * Updates to StopTimes for the trip (both future, i.e., predictions, and in
   * some cases, past ones, i.e., those that already happened).
   * The updates must be sorted by stop_sequence, and apply for all the
   * following stops of the trip up to the next specified one.
   * Example 1:
   * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
   * delay of 0 for stop_sequence of the current stop means that the trip is
   * exactly on time.
   * Example 2:
   * For the same trip instance, 3 StopTimeUpdates are provided:
   * - delay of 5 min for stop_sequence 3
   * - delay of 1 min for stop_sequence 8
   * - delay of unspecified duration for stop_sequence 10
   * This will be interpreted as:
   * - stop_sequences 3,4,5,6,7 have delay of 5 min.
   * - stop_sequences 8,9 have delay of 1 min.
   * - stop_sequences 10,... have unknown delay.
   */
  size_t n_stop_time_update;
  TransitRealtime__TripUpdate__StopTimeUpdate **stop_time_update;
  /*
   * Moment at which the vehicle's real-time progress was measured. In POSIX
   * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  /*
   * The current schedule deviation for the trip.  Delay should only be
   * specified when the prediction is given relative to some existing schedule
   * in GTFS.
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   * Delay information in StopTimeUpdates take precedent of trip-level delay
   * information, such that trip-level delay is only propagated until the next
   * stop along the trip with a StopTimeUpdate delay value specified.
   * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
   * value indicating when the delay value was last updated, in order to
   * evaluate the freshness of the data.
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   */
  protobuf_c_boolean has_delay;
  int32_t delay;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__descriptor) \
    , NULL, NULL, 0,NULL, 0, 0, 0, 0 }


/*
 * Realtime positioning information for a given vehicle.
 */
struct  _TransitRealtime__VehiclePosition
{
  ProtobufCMessage base;
  /*
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   */
  TransitRealtime__TripDescriptor *trip;
  /*
   * Additional information on the vehicle that is serving this trip.
   */
  TransitRealtime__VehicleDescriptor *vehicle;
  /*
   * Current position of this vehicle.
   */
  TransitRealtime__Position *position;
  /*
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   */
  protobuf_c_boolean has_current_stop_sequence;
  uint32_t current_stop_sequence;
  /*
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   */
  char *stop_id;
  /*
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   */
  protobuf_c_boolean has_current_status;
  TransitRealtime__VehiclePosition__VehicleStopStatus current_status;
  /*
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  protobuf_c_boolean has_congestion_level;
  TransitRealtime__VehiclePosition__CongestionLevel congestion_level;
  protobuf_c_boolean has_occupancy_status;
  TransitRealtime__VehiclePosition__OccupancyStatus occupancy_status;
};
#define TRANSIT_REALTIME__VEHICLE_POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__vehicle_position__descriptor) \
    , NULL, NULL, NULL, 0, 0, NULL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO, 0, 0, 0, TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY }


/*
 * An alert, indicating some sort of incident in the public transit network.
 */
struct  _TransitRealtime__Alert
{
  ProtobufCMessage base;
  /*
   * Time when the alert should be shown to the user. If missing, the
   * alert will be shown as long as it appears in the feed.
   * If multiple ranges are given, the alert will be shown during all of them.
   */
  size_t n_active_period;
  TransitRealtime__TimeRange **active_period;
  /*
   * Entities whose users we should notify of this alert.
   */
  size_t n_informed_entity;
  TransitRealtime__EntitySelector **informed_entity;
  protobuf_c_boolean has_cause;
  TransitRealtime__Alert__Cause cause;
  protobuf_c_boolean has_effect;
  TransitRealtime__Alert__Effect effect;
  /*
   * The URL which provides additional information about the alert.
   */
  TransitRealtime__TranslatedString *url;
  /*
   * Alert header. Contains a short summary of the alert text as plain-text.
   */
  TransitRealtime__TranslatedString *header_text;
  /*
   * Full description for the alert as plain-text. The information in the
   * description should add to the information of the header.
   */
  TransitRealtime__TranslatedString *description_text;
};
#define TRANSIT_REALTIME__ALERT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__alert__descriptor) \
    , 0,NULL, 0,NULL, 0, TRANSIT_REALTIME__ALERT__CAUSE__UNKNOWN_CAUSE, 0, TRANSIT_REALTIME__ALERT__EFFECT__UNKNOWN_EFFECT, NULL, NULL, NULL }


/*
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 */
struct  _TransitRealtime__TimeRange
{
  ProtobufCMessage base;
  /*
   * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval starts at minus infinity.
   */
  protobuf_c_boolean has_start;
  uint64_t start;
  /*
   * End time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval ends at plus infinity.
   */
  protobuf_c_boolean has_end;
  uint64_t end;
};
#define TRANSIT_REALTIME__TIME_RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__time_range__descriptor) \
    , 0, 0, 0, 0 }


/*
 * A position.
 */
struct  _TransitRealtime__Position
{
  ProtobufCMessage base;
  /*
   * Degrees North, in the WGS-84 coordinate system.
   */
  float latitude;
  /*
   * Degrees East, in the WGS-84 coordinate system.
   */
  float longitude;
  /*
   * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
   * This can be the compass bearing, or the direction towards the next stop
   * or intermediate location.
   * This should not be direction deduced from the sequence of previous
   * positions, which can be computed from previous data.
   */
  protobuf_c_boolean has_bearing;
  float bearing;
  /*
   * Odometer value, in meters.
   */
  protobuf_c_boolean has_odometer;
  double odometer;
  /*
   * Momentary speed measured by the vehicle, in meters per second.
   */
  protobuf_c_boolean has_speed;
  float speed;
};
#define TRANSIT_REALTIME__POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__position__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0 }


/*
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 */
struct  _TransitRealtime__TripDescriptor
{
  ProtobufCMessage base;
  /*
   * The trip_id from the GTFS feed that this selector refers to.
   * For non frequency-based trips, this field is enough to uniquely identify
   * the trip. For frequency-based trip, start_time and start_date might also be
   * necessary.
   */
  char *trip_id;
  /*
   * The route_id from the GTFS that this selector refers to.
   */
  char *route_id;
  /*
   * The direction_id from the GTFS feed trips.txt file, indicating the
   * direction of travel for trips this selector refers to. This field is
   * still experimental, and subject to change. It may be formally adopted in
   * the future.
   */
  protobuf_c_boolean has_direction_id;
  uint32_t direction_id;
  /*
   * The initially scheduled start time of this trip instance.
   * When the trip_id corresponds to a non-frequency-based trip, this field
   * should either be omitted or be equal to the value in the GTFS feed. When
   * the trip_id corresponds to a frequency-based trip, the start_time must be
   * specified for trip updates and vehicle positions. If the trip corresponds
   * to exact_times=1 GTFS record, then start_time must be some multiple
   * (including zero) of headway_secs later than frequencies.txt start_time for
   * the corresponding time period. If the trip corresponds to exact_times=0,
   * then its start_time may be arbitrary, and is initially expected to be the
   * first departure of the trip. Once established, the start_time of this
   * frequency-based trip should be considered immutable, even if the first
   * departure time changes -- that time change may instead be reflected in a
   * StopTimeUpdate.
   * Format and semantics of the field is same as that of
   * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
   */
  char *start_time;
  /*
   * The scheduled start date of this trip instance.
   * Must be provided to disambiguate trips that are so late as to collide with
   * a scheduled trip on a next day. For example, for a train that departs 8:00
   * and 20:00 every day, and is 12 hours late, there would be two distinct
   * trips on the same time.
   * This field can be provided but is not mandatory for schedules in which such
   * collisions are impossible - for example, a service running on hourly
   * schedule where a vehicle that is one hour late is not considered to be
   * related to schedule anymore.
   * In YYYYMMDD format.
   */
  char *start_date;
  protobuf_c_boolean has_schedule_relationship;
  TransitRealtime__TripDescriptor__ScheduleRelationship schedule_relationship;
};
#define TRANSIT_REALTIME__TRIP_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_descriptor__descriptor) \
    , NULL, NULL, 0, 0, NULL, NULL, 0, TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED }


/*
 * Identification information for the vehicle performing the trip.
 */
struct  _TransitRealtime__VehicleDescriptor
{
  ProtobufCMessage base;
  /*
   * Internal system identification of the vehicle. Should be unique per
   * vehicle, and can be used for tracking the vehicle as it proceeds through
   * the system.
   */
  char *id;
  /*
   * User visible label, i.e., something that must be shown to the passenger to
   * help identify the correct vehicle.
   */
  char *label;
  /*
   * The license plate of the vehicle.
   */
  char *license_plate;
};
#define TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__vehicle_descriptor__descriptor) \
    , NULL, NULL, NULL }


/*
 * A selector for an entity in a GTFS feed.
 */
struct  _TransitRealtime__EntitySelector
{
  ProtobufCMessage base;
  /*
   * The values of the fields should correspond to the appropriate fields in the
   * GTFS feed.
   * At least one specifier must be given. If several are given, then the
   * matching has to apply to all the given specifiers.
   */
  char *agency_id;
  char *route_id;
  /*
   * corresponds to route_type in GTFS.
   */
  protobuf_c_boolean has_route_type;
  int32_t route_type;
  TransitRealtime__TripDescriptor *trip;
  char *stop_id;
};
#define TRANSIT_REALTIME__ENTITY_SELECTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__entity_selector__descriptor) \
    , NULL, NULL, 0, 0, NULL, NULL }


struct  _TransitRealtime__TranslatedString__Translation
{
  ProtobufCMessage base;
  /*
   * A UTF-8 string containing the message.
   */
  char *text;
  /*
   * BCP-47 language code. Can be omitted if the language is unknown or if
   * no i18n is done at all for the feed. At most one translation is
   * allowed to have an unspecified language tag.
   */
  char *language;
};
#define TRANSIT_REALTIME__TRANSLATED_STRING__TRANSLATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_string__translation__descriptor) \
    , NULL, NULL }


/*
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 */
struct  _TransitRealtime__TranslatedString
{
  ProtobufCMessage base;
  /*
   * At least one translation must be provided.
   */
  size_t n_translation;
  TransitRealtime__TranslatedString__Translation **translation;
};
#define TRANSIT_REALTIME__TRANSLATED_STRING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_string__descriptor) \
    , 0,NULL }


/* TransitRealtime__FeedMessage methods */
void   transit_realtime__feed_message__init
                     (TransitRealtime__FeedMessage         *message);
size_t transit_realtime__feed_message__get_packed_size
                     (const TransitRealtime__FeedMessage   *message);
size_t transit_realtime__feed_message__pack
                     (const TransitRealtime__FeedMessage   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_message__pack_to_buffer
                     (const TransitRealtime__FeedMessage   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedMessage *
       transit_realtime__feed_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_message__free_unpacked
                     (TransitRealtime__FeedMessage *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__FeedHeader methods */
void   transit_realtime__feed_header__init
                     (TransitRealtime__FeedHeader         *message);
size_t transit_realtime__feed_header__get_packed_size
                     (const TransitRealtime__FeedHeader   *message);
size_t transit_realtime__feed_header__pack
                     (const TransitRealtime__FeedHeader   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_header__pack_to_buffer
                     (const TransitRealtime__FeedHeader   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedHeader *
       transit_realtime__feed_header__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_header__free_unpacked
                     (TransitRealtime__FeedHeader *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__FeedEntity methods */
void   transit_realtime__feed_entity__init
                     (TransitRealtime__FeedEntity         *message);
size_t transit_realtime__feed_entity__get_packed_size
                     (const TransitRealtime__FeedEntity   *message);
size_t transit_realtime__feed_entity__pack
                     (const TransitRealtime__FeedEntity   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_entity__pack_to_buffer
                     (const TransitRealtime__FeedEntity   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedEntity *
       transit_realtime__feed_entity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_entity__free_unpacked
                     (TransitRealtime__FeedEntity *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TripUpdate__StopTimeEvent methods */
void   transit_realtime__trip_update__stop_time_event__init
                     (TransitRealtime__TripUpdate__StopTimeEvent         *message);
/* TransitRealtime__TripUpdate__StopTimeUpdate methods */
void   transit_realtime__trip_update__stop_time_update__init
                     (TransitRealtime__TripUpdate__StopTimeUpdate         *message);
/* TransitRealtime__TripUpdate methods */
void   transit_realtime__trip_update__init
                     (TransitRealtime__TripUpdate         *message);
size_t transit_realtime__trip_update__get_packed_size
                     (const TransitRealtime__TripUpdate   *message);
size_t transit_realtime__trip_update__pack
                     (const TransitRealtime__TripUpdate   *message,
                      uint8_t             *out);
size_t transit_realtime__trip_update__pack_to_buffer
                     (const TransitRealtime__TripUpdate   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TripUpdate *
       transit_realtime__trip_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__trip_update__free_unpacked
                     (TransitRealtime__TripUpdate *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__VehiclePosition methods */
void   transit_realtime__vehicle_position__init
                     (TransitRealtime__VehiclePosition         *message);
size_t transit_realtime__vehicle_position__get_packed_size
                     (const TransitRealtime__VehiclePosition   *message);
size_t transit_realtime__vehicle_position__pack
                     (const TransitRealtime__VehiclePosition   *message,
                      uint8_t             *out);
size_t transit_realtime__vehicle_position__pack_to_buffer
                     (const TransitRealtime__VehiclePosition   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__VehiclePosition *
       transit_realtime__vehicle_position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__vehicle_position__free_unpacked
                     (TransitRealtime__VehiclePosition *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Alert methods */
void   transit_realtime__alert__init
                     (TransitRealtime__Alert         *message);
size_t transit_realtime__alert__get_packed_size
                     (const TransitRealtime__Alert   *message);
size_t transit_realtime__alert__pack
                     (const TransitRealtime__Alert   *message,
                      uint8_t             *out);
size_t transit_realtime__alert__pack_to_buffer
                     (const TransitRealtime__Alert   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Alert *
       transit_realtime__alert__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__alert__free_unpacked
                     (TransitRealtime__Alert *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TimeRange methods */
void   transit_realtime__time_range__init
                     (TransitRealtime__TimeRange         *message);
size_t transit_realtime__time_range__get_packed_size
                     (const TransitRealtime__TimeRange   *message);
size_t transit_realtime__time_range__pack
                     (const TransitRealtime__TimeRange   *message,
                      uint8_t             *out);
size_t transit_realtime__time_range__pack_to_buffer
                     (const TransitRealtime__TimeRange   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TimeRange *
       transit_realtime__time_range__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__time_range__free_unpacked
                     (TransitRealtime__TimeRange *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Position methods */
void   transit_realtime__position__init
                     (TransitRealtime__Position         *message);
size_t transit_realtime__position__get_packed_size
                     (const TransitRealtime__Position   *message);
size_t transit_realtime__position__pack
                     (const TransitRealtime__Position   *message,
                      uint8_t             *out);
size_t transit_realtime__position__pack_to_buffer
                     (const TransitRealtime__Position   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Position *
       transit_realtime__position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__position__free_unpacked
                     (TransitRealtime__Position *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TripDescriptor methods */
void   transit_realtime__trip_descriptor__init
                     (TransitRealtime__TripDescriptor         *message);
size_t transit_realtime__trip_descriptor__get_packed_size
                     (const TransitRealtime__TripDescriptor   *message);
size_t transit_realtime__trip_descriptor__pack
                     (const TransitRealtime__TripDescriptor   *message,
                      uint8_t             *out);
size_t transit_realtime__trip_descriptor__pack_to_buffer
                     (const TransitRealtime__TripDescriptor   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TripDescriptor *
       transit_realtime__trip_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__trip_descriptor__free_unpacked
                     (TransitRealtime__TripDescriptor *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__VehicleDescriptor methods */
void   transit_realtime__vehicle_descriptor__init
                     (TransitRealtime__VehicleDescriptor         *message);
size_t transit_realtime__vehicle_descriptor__get_packed_size
                     (const TransitRealtime__VehicleDescriptor   *message);
size_t transit_realtime__vehicle_descriptor__pack
                     (const TransitRealtime__VehicleDescriptor   *message,
                      uint8_t             *out);
size_t transit_realtime__vehicle_descriptor__pack_to_buffer
                     (const TransitRealtime__VehicleDescriptor   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__VehicleDescriptor *
       transit_realtime__vehicle_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__vehicle_descriptor__free_unpacked
                     (TransitRealtime__VehicleDescriptor *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__EntitySelector methods */
void   transit_realtime__entity_selector__init
                     (TransitRealtime__EntitySelector         *message);
size_t transit_realtime__entity_selector__get_packed_size
                     (const TransitRealtime__EntitySelector   *message);
size_t transit_realtime__entity_selector__pack
                     (const TransitRealtime__EntitySelector   *message,
                      uint8_t             *out);
size_t transit_realtime__entity_selector__pack_to_buffer
                     (const TransitRealtime__EntitySelector   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__EntitySelector *
       transit_realtime__entity_selector__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__entity_selector__free_unpacked
                     (TransitRealtime__EntitySelector *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TranslatedString__Translation methods */
void   transit_realtime__translated_string__translation__init
                     (TransitRealtime__TranslatedString__Translation         *message);
/* TransitRealtime__TranslatedString methods */
void   transit_realtime__translated_string__init
                     (TransitRealtime__TranslatedString         *message);
size_t transit_realtime__translated_string__get_packed_size
                     (const TransitRealtime__TranslatedString   *message);
size_t transit_realtime__translated_string__pack
                     (const TransitRealtime__TranslatedString   *message,
                      uint8_t             *out);
size_t transit_realtime__translated_string__pack_to_buffer
                     (const TransitRealtime__TranslatedString   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TranslatedString *
       transit_realtime__translated_string__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__translated_string__free_unpacked
                     (TransitRealtime__TranslatedString *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*TransitRealtime__FeedMessage_Closure)
                 (const TransitRealtime__FeedMessage *message,
                  void *closure_data);
typedef void (*TransitRealtime__FeedHeader_Closure)
                 (const TransitRealtime__FeedHeader *message,
                  void *closure_data);
typedef void (*TransitRealtime__FeedEntity_Closure)
                 (const TransitRealtime__FeedEntity *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__StopTimeEvent_Closure)
                 (const TransitRealtime__TripUpdate__StopTimeEvent *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__StopTimeUpdate_Closure)
                 (const TransitRealtime__TripUpdate__StopTimeUpdate *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate_Closure)
                 (const TransitRealtime__TripUpdate *message,
                  void *closure_data);
typedef void (*TransitRealtime__VehiclePosition_Closure)
                 (const TransitRealtime__VehiclePosition *message,
                  void *closure_data);
typedef void (*TransitRealtime__Alert_Closure)
                 (const TransitRealtime__Alert *message,
                  void *closure_data);
typedef void (*TransitRealtime__TimeRange_Closure)
                 (const TransitRealtime__TimeRange *message,
                  void *closure_data);
typedef void (*TransitRealtime__Position_Closure)
                 (const TransitRealtime__Position *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripDescriptor_Closure)
                 (const TransitRealtime__TripDescriptor *message,
                  void *closure_data);
typedef void (*TransitRealtime__VehicleDescriptor_Closure)
                 (const TransitRealtime__VehicleDescriptor *message,
                  void *closure_data);
typedef void (*TransitRealtime__EntitySelector_Closure)
                 (const TransitRealtime__EntitySelector *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedString__Translation_Closure)
                 (const TransitRealtime__TranslatedString__Translation *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedString_Closure)
                 (const TransitRealtime__TranslatedString *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor transit_realtime__feed_message__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__feed_header__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__feed_header__incrementality__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__feed_entity__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__stop_time_event__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__stop_time_update__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__trip_update__stop_time_update__schedule_relationship__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__vehicle_position__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__vehicle_stop_status__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__congestion_level__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__occupancy_status__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__alert__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__alert__cause__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__alert__effect__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__time_range__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__position__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_descriptor__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__trip_descriptor__schedule_relationship__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__vehicle_descriptor__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__entity_selector__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_string__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_string__translation__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED */
