// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_gtfs_2drealtime_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gtfs_2drealtime_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_gtfs_2drealtime_2eproto;
namespace transit_realtime {
class Alert;
struct AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class EntitySelector;
struct EntitySelectorDefaultTypeInternal;
extern EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
class FeedEntity;
struct FeedEntityDefaultTypeInternal;
extern FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
class FeedHeader;
struct FeedHeaderDefaultTypeInternal;
extern FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
class FeedMessage;
struct FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TranslatedString;
struct TranslatedStringDefaultTypeInternal;
extern TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
class TranslatedString_Translation;
struct TranslatedString_TranslationDefaultTypeInternal;
extern TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
class TripDescriptor;
struct TripDescriptorDefaultTypeInternal;
extern TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
class TripUpdate;
struct TripUpdateDefaultTypeInternal;
extern TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
class TripUpdate_StopTimeEvent;
struct TripUpdate_StopTimeEventDefaultTypeInternal;
extern TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
class TripUpdate_StopTimeUpdate;
struct TripUpdate_StopTimeUpdateDefaultTypeInternal;
extern TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
class VehicleDescriptor;
struct VehicleDescriptorDefaultTypeInternal;
extern VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
class VehiclePosition;
struct VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
}  // namespace transit_realtime
PROTOBUF_NAMESPACE_OPEN
template <>
::transit_realtime::Alert* Arena::CreateMaybeMessage<::transit_realtime::Alert>(Arena*);
template <>
::transit_realtime::EntitySelector* Arena::CreateMaybeMessage<::transit_realtime::EntitySelector>(Arena*);
template <>
::transit_realtime::FeedEntity* Arena::CreateMaybeMessage<::transit_realtime::FeedEntity>(Arena*);
template <>
::transit_realtime::FeedHeader* Arena::CreateMaybeMessage<::transit_realtime::FeedHeader>(Arena*);
template <>
::transit_realtime::FeedMessage* Arena::CreateMaybeMessage<::transit_realtime::FeedMessage>(Arena*);
template <>
::transit_realtime::Position* Arena::CreateMaybeMessage<::transit_realtime::Position>(Arena*);
template <>
::transit_realtime::TimeRange* Arena::CreateMaybeMessage<::transit_realtime::TimeRange>(Arena*);
template <>
::transit_realtime::TranslatedString* Arena::CreateMaybeMessage<::transit_realtime::TranslatedString>(Arena*);
template <>
::transit_realtime::TranslatedString_Translation* Arena::CreateMaybeMessage<::transit_realtime::TranslatedString_Translation>(Arena*);
template <>
::transit_realtime::TripDescriptor* Arena::CreateMaybeMessage<::transit_realtime::TripDescriptor>(Arena*);
template <>
::transit_realtime::TripUpdate* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate>(Arena*);
template <>
::transit_realtime::TripUpdate_StopTimeEvent* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(Arena*);
template <>
::transit_realtime::TripUpdate_StopTimeUpdate* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeUpdate>(Arena*);
template <>
::transit_realtime::VehicleDescriptor* Arena::CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(Arena*);
template <>
::transit_realtime::VehiclePosition* Arena::CreateMaybeMessage<::transit_realtime::VehiclePosition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace transit_realtime {
enum FeedHeader_Incrementality : int {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1,
};

bool FeedHeader_Incrementality_IsValid(int value);
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = static_cast<FeedHeader_Incrementality>(0);
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = static_cast<FeedHeader_Incrementality>(1);
constexpr int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FeedHeader_Incrementality_descriptor();
template <typename T>
const std::string& FeedHeader_Incrementality_Name(T value) {
  static_assert(std::is_same<T, FeedHeader_Incrementality>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Incrementality_Name().");
  return FeedHeader_Incrementality_Name(static_cast<FeedHeader_Incrementality>(value));
}
template <>
inline const std::string& FeedHeader_Incrementality_Name(FeedHeader_Incrementality value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FeedHeader_Incrementality_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool FeedHeader_Incrementality_Parse(absl::string_view name, FeedHeader_Incrementality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FeedHeader_Incrementality>(
      FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship : int {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2,
};

bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(0);
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(2);
constexpr int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
template <typename T>
const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(T value) {
  static_assert(std::is_same<T, TripUpdate_StopTimeUpdate_ScheduleRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleRelationship_Name().");
  return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(value));
}
template <>
inline const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(absl::string_view name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
      TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus : int {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2,
};

bool VehiclePosition_VehicleStopStatus_IsValid(int value);
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = static_cast<VehiclePosition_VehicleStopStatus>(0);
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = static_cast<VehiclePosition_VehicleStopStatus>(2);
constexpr int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VehiclePosition_VehicleStopStatus_descriptor();
template <typename T>
const std::string& VehiclePosition_VehicleStopStatus_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_VehicleStopStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VehicleStopStatus_Name().");
  return VehiclePosition_VehicleStopStatus_Name(static_cast<VehiclePosition_VehicleStopStatus>(value));
}
template <>
inline const std::string& VehiclePosition_VehicleStopStatus_Name(VehiclePosition_VehicleStopStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VehiclePosition_VehicleStopStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VehiclePosition_VehicleStopStatus_Parse(absl::string_view name, VehiclePosition_VehicleStopStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
      VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel : int {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4,
};

bool VehiclePosition_CongestionLevel_IsValid(int value);
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = static_cast<VehiclePosition_CongestionLevel>(0);
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = static_cast<VehiclePosition_CongestionLevel>(4);
constexpr int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VehiclePosition_CongestionLevel_descriptor();
template <typename T>
const std::string& VehiclePosition_CongestionLevel_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_CongestionLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CongestionLevel_Name().");
  return VehiclePosition_CongestionLevel_Name(static_cast<VehiclePosition_CongestionLevel>(value));
}
template <>
inline const std::string& VehiclePosition_CongestionLevel_Name(VehiclePosition_CongestionLevel value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VehiclePosition_CongestionLevel_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool VehiclePosition_CongestionLevel_Parse(absl::string_view name, VehiclePosition_CongestionLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
      VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum VehiclePosition_OccupancyStatus : int {
  VehiclePosition_OccupancyStatus_EMPTY = 0,
  VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE = 1,
  VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE = 2,
  VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY = 3,
  VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY = 4,
  VehiclePosition_OccupancyStatus_FULL = 5,
  VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS = 6,
};

bool VehiclePosition_OccupancyStatus_IsValid(int value);
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MIN = static_cast<VehiclePosition_OccupancyStatus>(0);
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MAX = static_cast<VehiclePosition_OccupancyStatus>(6);
constexpr int VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VehiclePosition_OccupancyStatus_descriptor();
template <typename T>
const std::string& VehiclePosition_OccupancyStatus_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_OccupancyStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OccupancyStatus_Name().");
  return VehiclePosition_OccupancyStatus_Name(static_cast<VehiclePosition_OccupancyStatus>(value));
}
template <>
inline const std::string& VehiclePosition_OccupancyStatus_Name(VehiclePosition_OccupancyStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VehiclePosition_OccupancyStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool VehiclePosition_OccupancyStatus_Parse(absl::string_view name, VehiclePosition_OccupancyStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_OccupancyStatus>(
      VehiclePosition_OccupancyStatus_descriptor(), name, value);
}
enum Alert_Cause : int {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12,
};

bool Alert_Cause_IsValid(int value);
constexpr Alert_Cause Alert_Cause_Cause_MIN = static_cast<Alert_Cause>(1);
constexpr Alert_Cause Alert_Cause_Cause_MAX = static_cast<Alert_Cause>(12);
constexpr int Alert_Cause_Cause_ARRAYSIZE = 12 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Alert_Cause_descriptor();
template <typename T>
const std::string& Alert_Cause_Name(T value) {
  static_assert(std::is_same<T, Alert_Cause>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Cause_Name().");
  return Alert_Cause_Name(static_cast<Alert_Cause>(value));
}
template <>
inline const std::string& Alert_Cause_Name(Alert_Cause value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Alert_Cause_descriptor,
                                                 1, 12>(
      static_cast<int>(value));
}
inline bool Alert_Cause_Parse(absl::string_view name, Alert_Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Cause>(
      Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect : int {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9,
};

bool Alert_Effect_IsValid(int value);
constexpr Alert_Effect Alert_Effect_Effect_MIN = static_cast<Alert_Effect>(1);
constexpr Alert_Effect Alert_Effect_Effect_MAX = static_cast<Alert_Effect>(9);
constexpr int Alert_Effect_Effect_ARRAYSIZE = 9 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Alert_Effect_descriptor();
template <typename T>
const std::string& Alert_Effect_Name(T value) {
  static_assert(std::is_same<T, Alert_Effect>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Effect_Name().");
  return Alert_Effect_Name(static_cast<Alert_Effect>(value));
}
template <>
inline const std::string& Alert_Effect_Name(Alert_Effect value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Alert_Effect_descriptor,
                                                 1, 9>(
      static_cast<int>(value));
}
inline bool Alert_Effect_Parse(absl::string_view name, Alert_Effect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Effect>(
      Alert_Effect_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship : int {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
};

bool TripDescriptor_ScheduleRelationship_IsValid(int value);
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = static_cast<TripDescriptor_ScheduleRelationship>(0);
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = static_cast<TripDescriptor_ScheduleRelationship>(3);
constexpr int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TripDescriptor_ScheduleRelationship_descriptor();
template <typename T>
const std::string& TripDescriptor_ScheduleRelationship_Name(T value) {
  static_assert(std::is_same<T, TripDescriptor_ScheduleRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleRelationship_Name().");
  return TripDescriptor_ScheduleRelationship_Name(static_cast<TripDescriptor_ScheduleRelationship>(value));
}
template <>
inline const std::string& TripDescriptor_ScheduleRelationship_Name(TripDescriptor_ScheduleRelationship value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TripDescriptor_ScheduleRelationship_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TripDescriptor_ScheduleRelationship_Parse(absl::string_view name, TripDescriptor_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
      TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class FeedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedMessage) */ {
 public:
  inline FeedMessage() : FeedMessage(nullptr) {}
  ~FeedMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedMessage(const FeedMessage& from);
  FeedMessage(FeedMessage&& from) noexcept
    : FeedMessage() {
    *this = ::std::move(from);
  }

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedMessage& operator=(FeedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedMessage* internal_default_instance() {
    return reinterpret_cast<const FeedMessage*>(
               &_FeedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FeedMessage& a, FeedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedMessage& from) {
    FeedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.FeedMessage";
  }
  protected:
  explicit FeedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .transit_realtime.FeedEntity entity = 2;
  int entity_size() const;
  private:
  int _internal_entity_size() const;

  public:
  void clear_entity() ;
  ::transit_realtime::FeedEntity* mutable_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >*
      mutable_entity();
  private:
  const ::transit_realtime::FeedEntity& _internal_entity(int index) const;
  ::transit_realtime::FeedEntity* _internal_add_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::FeedEntity>& _internal_entity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::FeedEntity>* _internal_mutable_entity();
  public:
  const ::transit_realtime::FeedEntity& entity(int index) const;
  ::transit_realtime::FeedEntity* add_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >&
      entity() const;
  // required .transit_realtime.FeedHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::transit_realtime::FeedHeader& header() const;
  PROTOBUF_NODISCARD ::transit_realtime::FeedHeader* release_header();
  ::transit_realtime::FeedHeader* mutable_header();
  void set_allocated_header(::transit_realtime::FeedHeader* header);
  private:
  const ::transit_realtime::FeedHeader& _internal_header() const;
  ::transit_realtime::FeedHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::transit_realtime::FeedHeader* header);
  ::transit_realtime::FeedHeader* unsafe_arena_release_header();
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;
    ::transit_realtime::FeedHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class FeedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedHeader) */ {
 public:
  inline FeedHeader() : FeedHeader(nullptr) {}
  ~FeedHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedHeader(const FeedHeader& from);
  FeedHeader(FeedHeader&& from) noexcept
    : FeedHeader() {
    *this = ::std::move(from);
  }

  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedHeader& operator=(FeedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedHeader* internal_default_instance() {
    return reinterpret_cast<const FeedHeader*>(
               &_FeedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeedHeader& a, FeedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedHeader& from) {
    FeedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.FeedHeader";
  }
  protected:
  explicit FeedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Incrementality = FeedHeader_Incrementality;
  static constexpr Incrementality FULL_DATASET = FeedHeader_Incrementality_FULL_DATASET;
  static constexpr Incrementality DIFFERENTIAL = FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static constexpr Incrementality Incrementality_MIN = FeedHeader_Incrementality_Incrementality_MIN;
  static constexpr Incrementality Incrementality_MAX = FeedHeader_Incrementality_Incrementality_MAX;
  static constexpr int Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  template <typename T>
  static inline const std::string& Incrementality_Name(T value) {
    return FeedHeader_Incrementality_Name(value);
  }
  static inline bool Incrementality_Parse(absl::string_view name, Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGtfsRealtimeVersionFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kIncrementalityFieldNumber = 2,
  };
  // required string gtfs_realtime_version = 1;
  bool has_gtfs_realtime_version() const;
  void clear_gtfs_realtime_version() ;
  const std::string& gtfs_realtime_version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gtfs_realtime_version(Arg_&& arg, Args_... args);
  std::string* mutable_gtfs_realtime_version();
  PROTOBUF_NODISCARD std::string* release_gtfs_realtime_version();
  void set_allocated_gtfs_realtime_version(std::string* ptr);

  private:
  const std::string& _internal_gtfs_realtime_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gtfs_realtime_version(
      const std::string& value);
  std::string* _internal_mutable_gtfs_realtime_version();

  public:
  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  bool has_incrementality() const;
  void clear_incrementality() ;
  ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  private:
  ::transit_realtime::FeedHeader_Incrementality _internal_incrementality() const;
  void _internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gtfs_realtime_version_;
    ::uint64_t timestamp_;
    int incrementality_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class FeedEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedEntity) */ {
 public:
  inline FeedEntity() : FeedEntity(nullptr) {}
  ~FeedEntity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeedEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedEntity(const FeedEntity& from);
  FeedEntity(FeedEntity&& from) noexcept
    : FeedEntity() {
    *this = ::std::move(from);
  }

  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedEntity& operator=(FeedEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedEntity* internal_default_instance() {
    return reinterpret_cast<const FeedEntity*>(
               &_FeedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeedEntity& a, FeedEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedEntity& from) {
    FeedEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.FeedEntity";
  }
  protected:
  explicit FeedEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTripUpdateFieldNumber = 3,
    kVehicleFieldNumber = 4,
    kAlertFieldNumber = 5,
    kIsDeletedFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .transit_realtime.TripUpdate trip_update = 3;
  bool has_trip_update() const;
  void clear_trip_update() ;
  const ::transit_realtime::TripUpdate& trip_update() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate* release_trip_update();
  ::transit_realtime::TripUpdate* mutable_trip_update();
  void set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update);
  private:
  const ::transit_realtime::TripUpdate& _internal_trip_update() const;
  ::transit_realtime::TripUpdate* _internal_mutable_trip_update();
  public:
  void unsafe_arena_set_allocated_trip_update(
      ::transit_realtime::TripUpdate* trip_update);
  ::transit_realtime::TripUpdate* unsafe_arena_release_trip_update();
  // optional .transit_realtime.VehiclePosition vehicle = 4;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehiclePosition& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehiclePosition* release_vehicle();
  ::transit_realtime::VehiclePosition* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle);
  private:
  const ::transit_realtime::VehiclePosition& _internal_vehicle() const;
  ::transit_realtime::VehiclePosition* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehiclePosition* vehicle);
  ::transit_realtime::VehiclePosition* unsafe_arena_release_vehicle();
  // optional .transit_realtime.Alert alert = 5;
  bool has_alert() const;
  void clear_alert() ;
  const ::transit_realtime::Alert& alert() const;
  PROTOBUF_NODISCARD ::transit_realtime::Alert* release_alert();
  ::transit_realtime::Alert* mutable_alert();
  void set_allocated_alert(::transit_realtime::Alert* alert);
  private:
  const ::transit_realtime::Alert& _internal_alert() const;
  ::transit_realtime::Alert* _internal_mutable_alert();
  public:
  void unsafe_arena_set_allocated_alert(
      ::transit_realtime::Alert* alert);
  ::transit_realtime::Alert* unsafe_arena_release_alert();
  // optional bool is_deleted = 2 [default = false];
  bool has_is_deleted() const;
  void clear_is_deleted() ;
  bool is_deleted() const;
  void set_is_deleted(bool value);

  private:
  bool _internal_is_deleted() const;
  void _internal_set_is_deleted(bool value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::transit_realtime::TripUpdate* trip_update_;
    ::transit_realtime::VehiclePosition* vehicle_;
    ::transit_realtime::Alert* alert_;
    bool is_deleted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeEvent) */ {
 public:
  inline TripUpdate_StopTimeEvent() : TripUpdate_StopTimeEvent(nullptr) {}
  ~TripUpdate_StopTimeEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);
  TripUpdate_StopTimeEvent(TripUpdate_StopTimeEvent&& from) noexcept
    : TripUpdate_StopTimeEvent() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeEvent& operator=(TripUpdate_StopTimeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeEvent* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeEvent*>(
               &_TripUpdate_StopTimeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripUpdate_StopTimeEvent& a, TripUpdate_StopTimeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeEvent& from) {
    TripUpdate_StopTimeEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TripUpdate.StopTimeEvent";
  }
  protected:
  explicit TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 2,
    kDelayFieldNumber = 1,
    kUncertaintyFieldNumber = 3,
  };
  // optional int64 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // optional int32 delay = 1;
  bool has_delay() const;
  void clear_delay() ;
  ::int32_t delay() const;
  void set_delay(::int32_t value);

  private:
  ::int32_t _internal_delay() const;
  void _internal_set_delay(::int32_t value);

  public:
  // optional int32 uncertainty = 3;
  bool has_uncertainty() const;
  void clear_uncertainty() ;
  ::int32_t uncertainty() const;
  void set_uncertainty(::int32_t value);

  private:
  ::int32_t _internal_uncertainty() const;
  void _internal_set_uncertainty(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t time_;
    ::int32_t delay_;
    ::int32_t uncertainty_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate) */ {
 public:
  inline TripUpdate_StopTimeUpdate() : TripUpdate_StopTimeUpdate(nullptr) {}
  ~TripUpdate_StopTimeUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);
  TripUpdate_StopTimeUpdate(TripUpdate_StopTimeUpdate&& from) noexcept
    : TripUpdate_StopTimeUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate& operator=(TripUpdate_StopTimeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate*>(
               &_TripUpdate_StopTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripUpdate_StopTimeUpdate& a, TripUpdate_StopTimeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeUpdate& from) {
    TripUpdate_StopTimeUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TripUpdate.StopTimeUpdate";
  }
  protected:
  explicit TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ScheduleRelationship = TripUpdate_StopTimeUpdate_ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship SKIPPED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static constexpr ScheduleRelationship NO_DATA = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  template <typename T>
  static inline const std::string& ScheduleRelationship_Name(T value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(absl::string_view name, ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 4,
    kArrivalFieldNumber = 2,
    kDepartureFieldNumber = 3,
    kStopSequenceFieldNumber = 1,
    kScheduleRelationshipFieldNumber = 5,
  };
  // optional string stop_id = 4;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* ptr);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  bool has_arrival() const;
  void clear_arrival() ;
  const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  void set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival);
  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_arrival() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_arrival();
  public:
  void unsafe_arena_set_allocated_arrival(
      ::transit_realtime::TripUpdate_StopTimeEvent* arrival);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_arrival();
  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  bool has_departure() const;
  void clear_departure() ;
  const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  void set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure);
  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_departure() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_departure();
  public:
  void unsafe_arena_set_allocated_departure(
      ::transit_realtime::TripUpdate_StopTimeEvent* departure);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_departure();
  // optional uint32 stop_sequence = 1;
  bool has_stop_sequence() const;
  void clear_stop_sequence() ;
  ::uint32_t stop_sequence() const;
  void set_stop_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(::uint32_t value);

  public:
  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  bool has_schedule_relationship() const;
  void clear_schedule_relationship() ;
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  private:
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
    ::transit_realtime::TripUpdate_StopTimeEvent* departure_;
    ::uint32_t stop_sequence_;
    int schedule_relationship_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TripUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate) */ {
 public:
  inline TripUpdate() : TripUpdate(nullptr) {}
  ~TripUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate(const TripUpdate& from);
  TripUpdate(TripUpdate&& from) noexcept
    : TripUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate& operator=(TripUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate*>(
               &_TripUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripUpdate& a, TripUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate& from) {
    TripUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TripUpdate";
  }
  protected:
  explicit TripUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeUpdateFieldNumber = 2,
    kTripFieldNumber = 1,
    kVehicleFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kDelayFieldNumber = 5,
  };
  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  int stop_time_update_size() const;
  private:
  int _internal_stop_time_update_size() const;

  public:
  void clear_stop_time_update() ;
  ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();
  private:
  const ::transit_realtime::TripUpdate_StopTimeUpdate& _internal_stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* _internal_add_stop_time_update();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>& _internal_stop_time_update() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>* _internal_mutable_stop_time_update();
  public:
  const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;
  // required .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();
  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);
  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehicleDescriptor* vehicle);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();
  // optional uint64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional int32 delay = 5;
  bool has_delay() const;
  void clear_delay() ;
  ::int32_t delay() const;
  void set_delay(::int32_t value);

  private:
  ::int32_t _internal_delay() const;
  void _internal_set_delay(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    ::uint64_t timestamp_;
    ::int32_t delay_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class VehiclePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition) */ {
 public:
  inline VehiclePosition() : VehiclePosition(nullptr) {}
  ~VehiclePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehiclePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehiclePosition(const VehiclePosition& from);
  VehiclePosition(VehiclePosition&& from) noexcept
    : VehiclePosition() {
    *this = ::std::move(from);
  }

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition& operator=(VehiclePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition*>(
               &_VehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VehiclePosition& a, VehiclePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(VehiclePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehiclePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehiclePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehiclePosition& from) {
    VehiclePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.VehiclePosition";
  }
  protected:
  explicit VehiclePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VehicleStopStatus = VehiclePosition_VehicleStopStatus;
  static constexpr VehicleStopStatus INCOMING_AT = VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static constexpr VehicleStopStatus STOPPED_AT = VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static constexpr VehicleStopStatus IN_TRANSIT_TO = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static constexpr VehicleStopStatus VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static constexpr VehicleStopStatus VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static constexpr int VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& VehicleStopStatus_Name(T value) {
    return VehiclePosition_VehicleStopStatus_Name(value);
  }
  static inline bool VehicleStopStatus_Parse(absl::string_view name, VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }

  using CongestionLevel = VehiclePosition_CongestionLevel;
  static constexpr CongestionLevel UNKNOWN_CONGESTION_LEVEL = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static constexpr CongestionLevel RUNNING_SMOOTHLY = VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static constexpr CongestionLevel STOP_AND_GO = VehiclePosition_CongestionLevel_STOP_AND_GO;
  static constexpr CongestionLevel CONGESTION = VehiclePosition_CongestionLevel_CONGESTION;
  static constexpr CongestionLevel SEVERE_CONGESTION = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static constexpr CongestionLevel CongestionLevel_MIN = VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static constexpr CongestionLevel CongestionLevel_MAX = VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static constexpr int CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  template <typename T>
  static inline const std::string& CongestionLevel_Name(T value) {
    return VehiclePosition_CongestionLevel_Name(value);
  }
  static inline bool CongestionLevel_Parse(absl::string_view name, CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }

  using OccupancyStatus = VehiclePosition_OccupancyStatus;
  static constexpr OccupancyStatus EMPTY = VehiclePosition_OccupancyStatus_EMPTY;
  static constexpr OccupancyStatus MANY_SEATS_AVAILABLE = VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE;
  static constexpr OccupancyStatus FEW_SEATS_AVAILABLE = VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE;
  static constexpr OccupancyStatus STANDING_ROOM_ONLY = VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus CRUSHED_STANDING_ROOM_ONLY = VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus FULL = VehiclePosition_OccupancyStatus_FULL;
  static constexpr OccupancyStatus NOT_ACCEPTING_PASSENGERS = VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS;
  static inline bool OccupancyStatus_IsValid(int value) {
    return VehiclePosition_OccupancyStatus_IsValid(value);
  }
  static constexpr OccupancyStatus OccupancyStatus_MIN = VehiclePosition_OccupancyStatus_OccupancyStatus_MIN;
  static constexpr OccupancyStatus OccupancyStatus_MAX = VehiclePosition_OccupancyStatus_OccupancyStatus_MAX;
  static constexpr int OccupancyStatus_ARRAYSIZE = VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OccupancyStatus_descriptor() {
    return VehiclePosition_OccupancyStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& OccupancyStatus_Name(T value) {
    return VehiclePosition_OccupancyStatus_Name(value);
  }
  static inline bool OccupancyStatus_Parse(absl::string_view name, OccupancyStatus* value) {
    return VehiclePosition_OccupancyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 7,
    kTripFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVehicleFieldNumber = 8,
    kCurrentStopSequenceFieldNumber = 3,
    kCongestionLevelFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kOccupancyStatusFieldNumber = 9,
    kCurrentStatusFieldNumber = 4,
  };
  // optional string stop_id = 7;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* ptr);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();
  // optional .transit_realtime.Position position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::transit_realtime::Position& position() const;
  PROTOBUF_NODISCARD ::transit_realtime::Position* release_position();
  ::transit_realtime::Position* mutable_position();
  void set_allocated_position(::transit_realtime::Position* position);
  private:
  const ::transit_realtime::Position& _internal_position() const;
  ::transit_realtime::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::transit_realtime::Position* position);
  ::transit_realtime::Position* unsafe_arena_release_position();
  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);
  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehicleDescriptor* vehicle);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();
  // optional uint32 current_stop_sequence = 3;
  bool has_current_stop_sequence() const;
  void clear_current_stop_sequence() ;
  ::uint32_t current_stop_sequence() const;
  void set_current_stop_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_current_stop_sequence() const;
  void _internal_set_current_stop_sequence(::uint32_t value);

  public:
  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  bool has_congestion_level() const;
  void clear_congestion_level() ;
  ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  private:
  ::transit_realtime::VehiclePosition_CongestionLevel _internal_congestion_level() const;
  void _internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  public:
  // optional uint64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
  bool has_occupancy_status() const;
  void clear_occupancy_status() ;
  ::transit_realtime::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  public:
  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  bool has_current_status() const;
  void clear_current_status() ;
  ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  private:
  ::transit_realtime::VehiclePosition_VehicleStopStatus _internal_current_status() const;
  void _internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::Position* position_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    ::uint32_t current_stop_sequence_;
    int congestion_level_;
    ::uint64_t timestamp_;
    int occupancy_status_;
    int current_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class Alert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {}
  ~Alert() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Alert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alert(const Alert& from);
  Alert(Alert&& from) noexcept
    : Alert() {
    *this = ::std::move(from);
  }

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
               &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Alert& a, Alert& b) {
    a.Swap(&b);
  }
  inline void Swap(Alert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Alert& from) {
    Alert::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.Alert";
  }
  protected:
  explicit Alert(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Cause = Alert_Cause;
  static constexpr Cause UNKNOWN_CAUSE = Alert_Cause_UNKNOWN_CAUSE;
  static constexpr Cause OTHER_CAUSE = Alert_Cause_OTHER_CAUSE;
  static constexpr Cause TECHNICAL_PROBLEM = Alert_Cause_TECHNICAL_PROBLEM;
  static constexpr Cause STRIKE = Alert_Cause_STRIKE;
  static constexpr Cause DEMONSTRATION = Alert_Cause_DEMONSTRATION;
  static constexpr Cause ACCIDENT = Alert_Cause_ACCIDENT;
  static constexpr Cause HOLIDAY = Alert_Cause_HOLIDAY;
  static constexpr Cause WEATHER = Alert_Cause_WEATHER;
  static constexpr Cause MAINTENANCE = Alert_Cause_MAINTENANCE;
  static constexpr Cause CONSTRUCTION = Alert_Cause_CONSTRUCTION;
  static constexpr Cause POLICE_ACTIVITY = Alert_Cause_POLICE_ACTIVITY;
  static constexpr Cause MEDICAL_EMERGENCY = Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN = Alert_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX = Alert_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE = Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  template <typename T>
  static inline const std::string& Cause_Name(T value) {
    return Alert_Cause_Name(value);
  }
  static inline bool Cause_Parse(absl::string_view name, Cause* value) {
    return Alert_Cause_Parse(name, value);
  }

  using Effect = Alert_Effect;
  static constexpr Effect NO_SERVICE = Alert_Effect_NO_SERVICE;
  static constexpr Effect REDUCED_SERVICE = Alert_Effect_REDUCED_SERVICE;
  static constexpr Effect SIGNIFICANT_DELAYS = Alert_Effect_SIGNIFICANT_DELAYS;
  static constexpr Effect DETOUR = Alert_Effect_DETOUR;
  static constexpr Effect ADDITIONAL_SERVICE = Alert_Effect_ADDITIONAL_SERVICE;
  static constexpr Effect MODIFIED_SERVICE = Alert_Effect_MODIFIED_SERVICE;
  static constexpr Effect OTHER_EFFECT = Alert_Effect_OTHER_EFFECT;
  static constexpr Effect UNKNOWN_EFFECT = Alert_Effect_UNKNOWN_EFFECT;
  static constexpr Effect STOP_MOVED = Alert_Effect_STOP_MOVED;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static constexpr Effect Effect_MIN = Alert_Effect_Effect_MIN;
  static constexpr Effect Effect_MAX = Alert_Effect_Effect_MAX;
  static constexpr int Effect_ARRAYSIZE = Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  template <typename T>
  static inline const std::string& Effect_Name(T value) {
    return Alert_Effect_Name(value);
  }
  static inline bool Effect_Parse(absl::string_view name, Effect* value) {
    return Alert_Effect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActivePeriodFieldNumber = 1,
    kInformedEntityFieldNumber = 5,
    kUrlFieldNumber = 8,
    kHeaderTextFieldNumber = 10,
    kDescriptionTextFieldNumber = 11,
    kCauseFieldNumber = 6,
    kEffectFieldNumber = 7,
  };
  // repeated .transit_realtime.TimeRange active_period = 1;
  int active_period_size() const;
  private:
  int _internal_active_period_size() const;

  public:
  void clear_active_period() ;
  ::transit_realtime::TimeRange* mutable_active_period(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_active_period();
  private:
  const ::transit_realtime::TimeRange& _internal_active_period(int index) const;
  ::transit_realtime::TimeRange* _internal_add_active_period();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TimeRange>& _internal_active_period() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TimeRange>* _internal_mutable_active_period();
  public:
  const ::transit_realtime::TimeRange& active_period(int index) const;
  ::transit_realtime::TimeRange* add_active_period();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >&
      active_period() const;
  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  int informed_entity_size() const;
  private:
  int _internal_informed_entity_size() const;

  public:
  void clear_informed_entity() ;
  ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >*
      mutable_informed_entity();
  private:
  const ::transit_realtime::EntitySelector& _internal_informed_entity(int index) const;
  ::transit_realtime::EntitySelector* _internal_add_informed_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::EntitySelector>& _internal_informed_entity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::EntitySelector>* _internal_mutable_informed_entity();
  public:
  const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  ::transit_realtime::EntitySelector* add_informed_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >&
      informed_entity() const;
  // optional .transit_realtime.TranslatedString url = 8;
  bool has_url() const;
  void clear_url() ;
  const ::transit_realtime::TranslatedString& url() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_url();
  ::transit_realtime::TranslatedString* mutable_url();
  void set_allocated_url(::transit_realtime::TranslatedString* url);
  private:
  const ::transit_realtime::TranslatedString& _internal_url() const;
  ::transit_realtime::TranslatedString* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::transit_realtime::TranslatedString* url);
  ::transit_realtime::TranslatedString* unsafe_arena_release_url();
  // optional .transit_realtime.TranslatedString header_text = 10;
  bool has_header_text() const;
  void clear_header_text() ;
  const ::transit_realtime::TranslatedString& header_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_header_text();
  ::transit_realtime::TranslatedString* mutable_header_text();
  void set_allocated_header_text(::transit_realtime::TranslatedString* header_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_header_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_header_text();
  public:
  void unsafe_arena_set_allocated_header_text(
      ::transit_realtime::TranslatedString* header_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_header_text();
  // optional .transit_realtime.TranslatedString description_text = 11;
  bool has_description_text() const;
  void clear_description_text() ;
  const ::transit_realtime::TranslatedString& description_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_description_text();
  ::transit_realtime::TranslatedString* mutable_description_text();
  void set_allocated_description_text(::transit_realtime::TranslatedString* description_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_description_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_description_text();
  public:
  void unsafe_arena_set_allocated_description_text(
      ::transit_realtime::TranslatedString* description_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_description_text();
  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  bool has_cause() const;
  void clear_cause() ;
  ::transit_realtime::Alert_Cause cause() const;
  void set_cause(::transit_realtime::Alert_Cause value);

  private:
  ::transit_realtime::Alert_Cause _internal_cause() const;
  void _internal_set_cause(::transit_realtime::Alert_Cause value);

  public:
  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  bool has_effect() const;
  void clear_effect() ;
  ::transit_realtime::Alert_Effect effect() const;
  void set_effect(::transit_realtime::Alert_Effect value);

  private:
  ::transit_realtime::Alert_Effect _internal_effect() const;
  void _internal_set_effect(::transit_realtime::Alert_Effect value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
    ::transit_realtime::TranslatedString* url_;
    ::transit_realtime::TranslatedString* header_text_;
    ::transit_realtime::TranslatedString* description_text_;
    int cause_;
    int effect_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional uint64 start = 1;
  bool has_start() const;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // optional uint64 end = 2;
  bool has_end() const;
  void clear_end() ;
  ::uint64_t end() const;
  void set_end(::uint64_t value);

  private:
  ::uint64_t _internal_end() const;
  void _internal_set_end(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t start_;
    ::uint64_t end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kOdometerFieldNumber = 4,
    kBearingFieldNumber = 3,
    kSpeedFieldNumber = 5,
  };
  // required float latitude = 1;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // required float longitude = 2;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // optional double odometer = 4;
  bool has_odometer() const;
  void clear_odometer() ;
  double odometer() const;
  void set_odometer(double value);

  private:
  double _internal_odometer() const;
  void _internal_set_odometer(double value);

  public:
  // optional float bearing = 3;
  bool has_bearing() const;
  void clear_bearing() ;
  float bearing() const;
  void set_bearing(float value);

  private:
  float _internal_bearing() const;
  void _internal_set_bearing(float value);

  public:
  // optional float speed = 5;
  bool has_speed() const;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float latitude_;
    float longitude_;
    double odometer_;
    float bearing_;
    float speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TripDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripDescriptor) */ {
 public:
  inline TripDescriptor() : TripDescriptor(nullptr) {}
  ~TripDescriptor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripDescriptor(const TripDescriptor& from);
  TripDescriptor(TripDescriptor&& from) noexcept
    : TripDescriptor() {
    *this = ::std::move(from);
  }

  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripDescriptor& operator=(TripDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripDescriptor* internal_default_instance() {
    return reinterpret_cast<const TripDescriptor*>(
               &_TripDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TripDescriptor& a, TripDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(TripDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripDescriptor& from) {
    TripDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TripDescriptor";
  }
  protected:
  explicit TripDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ScheduleRelationship = TripDescriptor_ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED = TripDescriptor_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship ADDED = TripDescriptor_ScheduleRelationship_ADDED;
  static constexpr ScheduleRelationship UNSCHEDULED = TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static constexpr ScheduleRelationship CANCELED = TripDescriptor_ScheduleRelationship_CANCELED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  template <typename T>
  static inline const std::string& ScheduleRelationship_Name(T value) {
    return TripDescriptor_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(absl::string_view name, ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTripIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kRouteIdFieldNumber = 5,
    kScheduleRelationshipFieldNumber = 4,
    kDirectionIdFieldNumber = 6,
  };
  // optional string trip_id = 1;
  bool has_trip_id() const;
  void clear_trip_id() ;
  const std::string& trip_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trip_id(Arg_&& arg, Args_... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* ptr);

  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(
      const std::string& value);
  std::string* _internal_mutable_trip_id();

  public:
  // optional string start_time = 2;
  bool has_start_time() const;
  void clear_start_time() ;
  const std::string& start_time() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* ptr);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // optional string start_date = 3;
  bool has_start_date() const;
  void clear_start_date() ;
  const std::string& start_date() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* ptr);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // optional string route_id = 5;
  bool has_route_id() const;
  void clear_route_id() ;
  const std::string& route_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route_id(Arg_&& arg, Args_... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* ptr);

  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(
      const std::string& value);
  std::string* _internal_mutable_route_id();

  public:
  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  bool has_schedule_relationship() const;
  void clear_schedule_relationship() ;
  ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  private:
  ::transit_realtime::TripDescriptor_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  public:
  // optional uint32 direction_id = 6;
  bool has_direction_id() const;
  void clear_direction_id() ;
  ::uint32_t direction_id() const;
  void set_direction_id(::uint32_t value);

  private:
  ::uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    int schedule_relationship_;
    ::uint32_t direction_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class VehicleDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehicleDescriptor) */ {
 public:
  inline VehicleDescriptor() : VehicleDescriptor(nullptr) {}
  ~VehicleDescriptor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleDescriptor(const VehicleDescriptor& from);
  VehicleDescriptor(VehicleDescriptor&& from) noexcept
    : VehicleDescriptor() {
    *this = ::std::move(from);
  }

  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleDescriptor& operator=(VehicleDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleDescriptor* internal_default_instance() {
    return reinterpret_cast<const VehicleDescriptor*>(
               &_VehicleDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VehicleDescriptor& a, VehicleDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleDescriptor& from) {
    VehicleDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.VehicleDescriptor";
  }
  protected:
  explicit VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kLicensePlateFieldNumber = 3,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string label = 2;
  bool has_label() const;
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // optional string license_plate = 3;
  bool has_license_plate() const;
  void clear_license_plate() ;
  const std::string& license_plate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_license_plate(Arg_&& arg, Args_... args);
  std::string* mutable_license_plate();
  PROTOBUF_NODISCARD std::string* release_license_plate();
  void set_allocated_license_plate(std::string* ptr);

  private:
  const std::string& _internal_license_plate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_plate(
      const std::string& value);
  std::string* _internal_mutable_license_plate();

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_plate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class EntitySelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.EntitySelector) */ {
 public:
  inline EntitySelector() : EntitySelector(nullptr) {}
  ~EntitySelector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntitySelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntitySelector(const EntitySelector& from);
  EntitySelector(EntitySelector&& from) noexcept
    : EntitySelector() {
    *this = ::std::move(from);
  }

  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySelector& operator=(EntitySelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitySelector* internal_default_instance() {
    return reinterpret_cast<const EntitySelector*>(
               &_EntitySelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EntitySelector& a, EntitySelector& b) {
    a.Swap(&b);
  }
  inline void Swap(EntitySelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntitySelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntitySelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntitySelector& from) {
    EntitySelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntitySelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.EntitySelector";
  }
  protected:
  explicit EntitySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgencyIdFieldNumber = 1,
    kRouteIdFieldNumber = 2,
    kStopIdFieldNumber = 5,
    kTripFieldNumber = 4,
    kRouteTypeFieldNumber = 3,
  };
  // optional string agency_id = 1;
  bool has_agency_id() const;
  void clear_agency_id() ;
  const std::string& agency_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agency_id(Arg_&& arg, Args_... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* ptr);

  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(
      const std::string& value);
  std::string* _internal_mutable_agency_id();

  public:
  // optional string route_id = 2;
  bool has_route_id() const;
  void clear_route_id() ;
  const std::string& route_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route_id(Arg_&& arg, Args_... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* ptr);

  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(
      const std::string& value);
  std::string* _internal_mutable_route_id();

  public:
  // optional string stop_id = 5;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* ptr);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripDescriptor trip = 4;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();
  // optional int32 route_type = 3;
  bool has_route_type() const;
  void clear_route_type() ;
  ::int32_t route_type() const;
  void set_route_type(::int32_t value);

  private:
  ::int32_t _internal_route_type() const;
  void _internal_set_route_type(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    ::int32_t route_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TranslatedString_Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString.Translation) */ {
 public:
  inline TranslatedString_Translation() : TranslatedString_Translation(nullptr) {}
  ~TranslatedString_Translation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString_Translation(const TranslatedString_Translation& from);
  TranslatedString_Translation(TranslatedString_Translation&& from) noexcept
    : TranslatedString_Translation() {
    *this = ::std::move(from);
  }

  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString_Translation& operator=(TranslatedString_Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString_Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString_Translation* internal_default_instance() {
    return reinterpret_cast<const TranslatedString_Translation*>(
               &_TranslatedString_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TranslatedString_Translation& a, TranslatedString_Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString_Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString_Translation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString_Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString_Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString_Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString_Translation& from) {
    TranslatedString_Translation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString_Translation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TranslatedString.Translation";
  }
  protected:
  explicit TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLanguageFieldNumber = 2,
  };
  // required string text = 1;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string language = 2;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* ptr);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};// -------------------------------------------------------------------

class TranslatedString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString) */ {
 public:
  inline TranslatedString() : TranslatedString(nullptr) {}
  ~TranslatedString() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString(const TranslatedString& from);
  TranslatedString(TranslatedString&& from) noexcept
    : TranslatedString() {
    *this = ::std::move(from);
  }

  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString& operator=(TranslatedString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString* internal_default_instance() {
    return reinterpret_cast<const TranslatedString*>(
               &_TranslatedString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TranslatedString& a, TranslatedString& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString& from) {
    TranslatedString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "transit_realtime.TranslatedString";
  }
  protected:
  explicit TranslatedString(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TranslatedString_Translation Translation;

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 1,
  };
  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  int translation_size() const;
  private:
  int _internal_translation_size() const;

  public:
  void clear_translation() ;
  ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
      mutable_translation();
  private:
  const ::transit_realtime::TranslatedString_Translation& _internal_translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* _internal_add_translation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>& _internal_translation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>* _internal_mutable_translation();
  public:
  const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* add_translation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
      translation() const;
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void FeedMessage::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::FeedHeader& FeedMessage::_internal_header() const {
  const ::transit_realtime::FeedHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::FeedHeader&>(
      ::transit_realtime::_FeedHeader_default_instance_);
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.header)
  return _internal_header();
}
inline void FeedMessage::unsafe_arena_set_allocated_header(
    ::transit_realtime::FeedHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedMessage.header)
}
inline ::transit_realtime::FeedHeader* FeedMessage::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::FeedHeader* FeedMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedMessage.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::transit_realtime::FeedHeader* FeedMessage::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::FeedHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() {
  ::transit_realtime::FeedHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.header)
  return _msg;
}
inline void FeedMessage::set_allocated_header(::transit_realtime::FeedHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedMessage.header)
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::_internal_entity_size() const {
  return _impl_.entity_.size();
}
inline int FeedMessage::entity_size() const {
  return _internal_entity_size();
}
inline void FeedMessage::clear_entity() {
  _internal_mutable_entity()->Clear();
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.entity)
  return _internal_mutable_entity()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >*
FeedMessage::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.FeedMessage.entity)
  return _internal_mutable_entity();
}
inline const ::transit_realtime::FeedEntity& FeedMessage::_internal_entity(int index) const {
  return _internal_entity().Get(index);
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.entity)
  return _internal_entity(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::_internal_add_entity() {
  return _internal_mutable_entity()->Add();
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() {
  ::transit_realtime::FeedEntity* _add = _internal_add_entity();
  // @@protoc_insertion_point(field_add:transit_realtime.FeedMessage.entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >&
FeedMessage::entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.FeedMessage.entity)
  return _internal_entity();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::FeedEntity>&
FeedMessage::_internal_entity() const {
  return _impl_.entity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::FeedEntity>*
FeedMessage::_internal_mutable_entity() {
  return &_impl_.entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::has_gtfs_realtime_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  _impl_.gtfs_realtime_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedHeader::gtfs_realtime_version() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _internal_gtfs_realtime_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedHeader::set_gtfs_realtime_version(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gtfs_realtime_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline std::string* FeedHeader::mutable_gtfs_realtime_version() {
  std::string* _s = _internal_mutable_gtfs_realtime_version();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _s;
}
inline const std::string& FeedHeader::_internal_gtfs_realtime_version() const {
  return _impl_.gtfs_realtime_version_.Get();
}
inline void FeedHeader::_internal_set_gtfs_realtime_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.gtfs_realtime_version_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedHeader::_internal_mutable_gtfs_realtime_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gtfs_realtime_version_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedHeader::release_gtfs_realtime_version() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedHeader.gtfs_realtime_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.gtfs_realtime_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gtfs_realtime_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gtfs_realtime_version_.IsDefault()) {
          _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedHeader.gtfs_realtime_version)
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::has_incrementality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FeedHeader::clear_incrementality() {
  _impl_.incrementality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.incrementality)
  return _internal_incrementality();
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
   _internal_set_incrementality(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.incrementality)
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::_internal_incrementality() const {
  return static_cast<::transit_realtime::FeedHeader_Incrementality>(_impl_.incrementality_);
}
inline void FeedHeader::_internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  assert(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.incrementality_ = value;
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FeedHeader::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t FeedHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.timestamp)
  return _internal_timestamp();
}
inline void FeedHeader::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.timestamp)
}
inline ::uint64_t FeedHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void FeedHeader::_internal_set_timestamp(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FeedEntity::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedEntity::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedEntity::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.id)
}
inline std::string* FeedEntity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.id)
  return _s;
}
inline const std::string& FeedEntity::_internal_id() const {
  return _impl_.id_.Get();
}
inline void FeedEntity::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedEntity::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* FeedEntity::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FeedEntity::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.id)
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::has_is_deleted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FeedEntity::clear_is_deleted() {
  _impl_.is_deleted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool FeedEntity::is_deleted() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.is_deleted)
  return _internal_is_deleted();
}
inline void FeedEntity::set_is_deleted(bool value) {
  _internal_set_is_deleted(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.is_deleted)
}
inline bool FeedEntity::_internal_is_deleted() const {
  return _impl_.is_deleted_;
}
inline void FeedEntity::_internal_set_is_deleted(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_deleted_ = value;
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::has_trip_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_update_ != nullptr);
  return value;
}
inline void FeedEntity::clear_trip_update() {
  if (_impl_.trip_update_ != nullptr) _impl_.trip_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate& FeedEntity::_internal_trip_update() const {
  const ::transit_realtime::TripUpdate* p = _impl_.trip_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate&>(
      ::transit_realtime::_TripUpdate_default_instance_);
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.trip_update)
  return _internal_trip_update();
}
inline void FeedEntity::unsafe_arena_set_allocated_trip_update(
    ::transit_realtime::TripUpdate* trip_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_update_);
  }
  _impl_.trip_update_ = trip_update;
  if (trip_update) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.trip_update)
}
inline ::transit_realtime::TripUpdate* FeedEntity::release_trip_update() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate* FeedEntity::unsafe_arena_release_trip_update() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.trip_update)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate* FeedEntity::_internal_mutable_trip_update() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trip_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate>(GetArenaForAllocation());
    _impl_.trip_update_ = p;
  }
  return _impl_.trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() {
  ::transit_realtime::TripUpdate* _msg = _internal_mutable_trip_update();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.trip_update)
  return _msg;
}
inline void FeedEntity::set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_update_;
  }
  if (trip_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip_update);
    if (message_arena != submessage_arena) {
      trip_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trip_update_ = trip_update;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.trip_update)
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void FeedEntity::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::_internal_vehicle() const {
  const ::transit_realtime::VehiclePosition* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehiclePosition&>(
      ::transit_realtime::_VehiclePosition_default_instance_);
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.vehicle)
  return _internal_vehicle();
}
inline void FeedEntity::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehiclePosition* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.vehicle)
}
inline ::transit_realtime::VehiclePosition* FeedEntity::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.vehicle)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehiclePosition>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() {
  ::transit_realtime::VehiclePosition* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.vehicle)
  return _msg;
}
inline void FeedEntity::set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.vehicle)
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::has_alert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alert_ != nullptr);
  return value;
}
inline void FeedEntity::clear_alert() {
  if (_impl_.alert_ != nullptr) _impl_.alert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::Alert& FeedEntity::_internal_alert() const {
  const ::transit_realtime::Alert* p = _impl_.alert_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Alert&>(
      ::transit_realtime::_Alert_default_instance_);
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.alert)
  return _internal_alert();
}
inline void FeedEntity::unsafe_arena_set_allocated_alert(
    ::transit_realtime::Alert* alert) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_);
  }
  _impl_.alert_ = alert;
  if (alert) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.alert)
}
inline ::transit_realtime::Alert* FeedEntity::release_alert() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::Alert* FeedEntity::unsafe_arena_release_alert() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.alert)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
  return temp;
}
inline ::transit_realtime::Alert* FeedEntity::_internal_mutable_alert() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.alert_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::Alert>(GetArenaForAllocation());
    _impl_.alert_ = p;
  }
  return _impl_.alert_;
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() {
  ::transit_realtime::Alert* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.alert)
  return _msg;
}
inline void FeedEntity::set_allocated_alert(::transit_realtime::Alert* alert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.alert_;
  }
  if (alert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(alert);
    if (message_arena != submessage_arena) {
      alert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.alert_ = alert;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.alert)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t TripUpdate_StopTimeEvent::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.delay)
  return _internal_delay();
}
inline void TripUpdate_StopTimeEvent::set_delay(::int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.delay)
}
inline ::int32_t TripUpdate_StopTimeEvent::_internal_delay() const {
  return _impl_.delay_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_delay(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.delay_ = value;
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t TripUpdate_StopTimeEvent::time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.time)
  return _internal_time();
}
inline void TripUpdate_StopTimeEvent::set_time(::int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.time)
}
inline ::int64_t TripUpdate_StopTimeEvent::_internal_time() const {
  return _impl_.time_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.time_ = value;
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  _impl_.uncertainty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t TripUpdate_StopTimeEvent::uncertainty() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
  return _internal_uncertainty();
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(::int32_t value) {
  _internal_set_uncertainty(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
}
inline ::int32_t TripUpdate_StopTimeEvent::_internal_uncertainty() const {
  return _impl_.uncertainty_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_uncertainty(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uncertainty_ = value;
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  _impl_.stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t TripUpdate_StopTimeUpdate::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
  return _internal_stop_sequence();
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(::uint32_t value) {
  _internal_set_stop_sequence(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
}
inline ::uint32_t TripUpdate_StopTimeUpdate::_internal_stop_sequence() const {
  return _impl_.stop_sequence_;
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_sequence(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stop_sequence_ = value;
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_StopTimeUpdate::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stop_id_.IsDefault()) {
          _impl_.stop_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arrival_ != nullptr);
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (_impl_.arrival_ != nullptr) _impl_.arrival_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_arrival() const {
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(
      ::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _internal_arrival();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_arrival(
    ::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = arrival;
  if (arrival) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_arrival() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_arrival() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.arrival_ = p;
  }
  return _impl_.arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_;
  }
  if (arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival);
    if (message_arena != submessage_arena) {
      arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.arrival_ = arrival;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.departure_ != nullptr);
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (_impl_.departure_ != nullptr) _impl_.departure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_departure() const {
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(
      ::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _internal_departure();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_departure(
    ::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = departure;
  if (departure) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_departure() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_departure() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.departure_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.departure_ = p;
  }
  return _impl_.departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.departure_;
  }
  if (departure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(departure);
    if (message_arena != submessage_arena) {
      departure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.departure_ = departure;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
   _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::_internal_schedule_relationship() const {
  return static_cast<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>(_impl_.schedule_relationship_);
}
inline void TripUpdate_StopTimeUpdate::_internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  assert(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void TripUpdate::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip)
  return _internal_trip();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.trip)
}
inline ::transit_realtime::TripDescriptor* TripUpdate::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip)
  return _msg;
}
inline void TripUpdate::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void TripUpdate::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::_internal_vehicle() const {
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(
      ::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.vehicle)
  return _internal_vehicle();
}
inline void TripUpdate::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.vehicle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.vehicle)
  return _msg;
}
inline void TripUpdate::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.vehicle)
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::_internal_stop_time_update_size() const {
  return _impl_.stop_time_update_.size();
}
inline int TripUpdate::stop_time_update_size() const {
  return _internal_stop_time_update_size();
}
inline void TripUpdate::clear_stop_time_update() {
  _internal_mutable_stop_time_update()->Clear();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.stop_time_update)
  return _internal_mutable_stop_time_update()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripUpdate.stop_time_update)
  return _internal_mutable_stop_time_update();
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::_internal_stop_time_update(int index) const {
  return _internal_stop_time_update().Get(index);
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.stop_time_update)
  return _internal_stop_time_update(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::_internal_add_stop_time_update() {
  return _internal_mutable_stop_time_update()->Add();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  ::transit_realtime::TripUpdate_StopTimeUpdate* _add = _internal_add_stop_time_update();
  // @@protoc_insertion_point(field_add:transit_realtime.TripUpdate.stop_time_update)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TripUpdate.stop_time_update)
  return _internal_stop_time_update();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>&
TripUpdate::_internal_stop_time_update() const {
  return _impl_.stop_time_update_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>*
TripUpdate::_internal_mutable_stop_time_update() {
  return &_impl_.stop_time_update_;
}

// optional uint64 timestamp = 4;
inline bool TripUpdate::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripUpdate::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t TripUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.timestamp)
  return _internal_timestamp();
}
inline void TripUpdate::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.timestamp)
}
inline ::uint64_t TripUpdate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void TripUpdate::_internal_set_timestamp(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}

// optional int32 delay = 5;
inline bool TripUpdate::has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripUpdate::clear_delay() {
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t TripUpdate::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.delay)
  return _internal_delay();
}
inline void TripUpdate::set_delay(::int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.delay)
}
inline ::int32_t TripUpdate::_internal_delay() const {
  return _impl_.delay_;
}
inline void TripUpdate::_internal_set_delay(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.delay_ = value;
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.trip)
  return _internal_trip();
}
inline void VehiclePosition::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.trip)
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.trip)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.trip)
  return _msg;
}
inline void VehiclePosition::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::_internal_vehicle() const {
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(
      ::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.vehicle)
  return _internal_vehicle();
}
inline void VehiclePosition::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.vehicle)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.vehicle)
  return _msg;
}
inline void VehiclePosition::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.vehicle)
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::Position& VehiclePosition::_internal_position() const {
  const ::transit_realtime::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Position&>(
      ::transit_realtime::_Position_default_instance_);
}
inline const ::transit_realtime::Position& VehiclePosition::position() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.position)
  return _internal_position();
}
inline void VehiclePosition::unsafe_arena_set_allocated_position(
    ::transit_realtime::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.position)
}
inline ::transit_realtime::Position* VehiclePosition::release_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::Position* VehiclePosition::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::transit_realtime::Position* VehiclePosition::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() {
  ::transit_realtime::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.position)
  return _msg;
}
inline void VehiclePosition::set_allocated_position(::transit_realtime::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.position)
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::has_current_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehiclePosition::clear_current_stop_sequence() {
  _impl_.current_stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t VehiclePosition::current_stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_stop_sequence)
  return _internal_current_stop_sequence();
}
inline void VehiclePosition::set_current_stop_sequence(::uint32_t value) {
  _internal_set_current_stop_sequence(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_stop_sequence)
}
inline ::uint32_t VehiclePosition::_internal_current_stop_sequence() const {
  return _impl_.current_stop_sequence_;
}
inline void VehiclePosition::_internal_set_current_stop_sequence(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.current_stop_sequence_ = value;
}

// optional string stop_id = 7;
inline bool VehiclePosition::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehiclePosition::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehiclePosition::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehiclePosition::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.stop_id)
}
inline std::string* VehiclePosition::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.stop_id)
  return _s;
}
inline const std::string& VehiclePosition::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void VehiclePosition::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehiclePosition::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehiclePosition::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehiclePosition::set_allocated_stop_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stop_id_.IsDefault()) {
          _impl_.stop_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.stop_id)
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::has_current_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void VehiclePosition::clear_current_status() {
  _impl_.current_status_ = 2;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_status)
  return _internal_current_status();
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
   _internal_set_current_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_status)
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::_internal_current_status() const {
  return static_cast<::transit_realtime::VehiclePosition_VehicleStopStatus>(_impl_.current_status_);
}
inline void VehiclePosition::_internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  assert(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.current_status_ = value;
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void VehiclePosition::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.timestamp)
  return _internal_timestamp();
}
inline void VehiclePosition::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.timestamp)
}
inline ::uint64_t VehiclePosition::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void VehiclePosition::_internal_set_timestamp(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.timestamp_ = value;
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::has_congestion_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void VehiclePosition::clear_congestion_level() {
  _impl_.congestion_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.congestion_level)
  return _internal_congestion_level();
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
   _internal_set_congestion_level(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.congestion_level)
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::_internal_congestion_level() const {
  return static_cast<::transit_realtime::VehiclePosition_CongestionLevel>(_impl_.congestion_level_);
}
inline void VehiclePosition::_internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  assert(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.congestion_level_ = value;
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
inline bool VehiclePosition::has_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void VehiclePosition::clear_occupancy_status() {
  _impl_.occupancy_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition::set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
   _internal_set_occupancy_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.occupancy_status)
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::_internal_occupancy_status() const {
  return static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(_impl_.occupancy_status_);
}
inline void VehiclePosition::_internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.occupancy_status_ = value;
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::_internal_active_period_size() const {
  return _impl_.active_period_.size();
}
inline int Alert::active_period_size() const {
  return _internal_active_period_size();
}
inline void Alert::clear_active_period() {
  _internal_mutable_active_period()->Clear();
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.active_period)
  return _internal_mutable_active_period()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >*
Alert::mutable_active_period() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.active_period)
  return _internal_mutable_active_period();
}
inline const ::transit_realtime::TimeRange& Alert::_internal_active_period(int index) const {
  return _internal_active_period().Get(index);
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.active_period)
  return _internal_active_period(index);
}
inline ::transit_realtime::TimeRange* Alert::_internal_add_active_period() {
  return _internal_mutable_active_period()->Add();
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() {
  ::transit_realtime::TimeRange* _add = _internal_add_active_period();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.active_period)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >&
Alert::active_period() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.active_period)
  return _internal_active_period();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TimeRange>&
Alert::_internal_active_period() const {
  return _impl_.active_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TimeRange>*
Alert::_internal_mutable_active_period() {
  return &_impl_.active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::_internal_informed_entity_size() const {
  return _impl_.informed_entity_.size();
}
inline int Alert::informed_entity_size() const {
  return _internal_informed_entity_size();
}
inline void Alert::clear_informed_entity() {
  _internal_mutable_informed_entity()->Clear();
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.informed_entity)
  return _internal_mutable_informed_entity()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >*
Alert::mutable_informed_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.informed_entity)
  return _internal_mutable_informed_entity();
}
inline const ::transit_realtime::EntitySelector& Alert::_internal_informed_entity(int index) const {
  return _internal_informed_entity().Get(index);
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.informed_entity)
  return _internal_informed_entity(index);
}
inline ::transit_realtime::EntitySelector* Alert::_internal_add_informed_entity() {
  return _internal_mutable_informed_entity()->Add();
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() {
  ::transit_realtime::EntitySelector* _add = _internal_add_informed_entity();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.informed_entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >&
Alert::informed_entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.informed_entity)
  return _internal_informed_entity();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::EntitySelector>&
Alert::_internal_informed_entity() const {
  return _impl_.informed_entity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::EntitySelector>*
Alert::_internal_mutable_informed_entity() {
  return &_impl_.informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::has_cause() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Alert::clear_cause() {
  _impl_.cause_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.cause)
  return _internal_cause();
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
   _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.cause)
}
inline ::transit_realtime::Alert_Cause Alert::_internal_cause() const {
  return static_cast<::transit_realtime::Alert_Cause>(_impl_.cause_);
}
inline void Alert::_internal_set_cause(::transit_realtime::Alert_Cause value) {
  assert(::transit_realtime::Alert_Cause_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cause_ = value;
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::has_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Alert::clear_effect() {
  _impl_.effect_ = 8;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.effect)
  return _internal_effect();
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
   _internal_set_effect(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.effect)
}
inline ::transit_realtime::Alert_Effect Alert::_internal_effect() const {
  return static_cast<::transit_realtime::Alert_Effect>(_impl_.effect_);
}
inline void Alert::_internal_set_effect(::transit_realtime::Alert_Effect value) {
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.effect_ = value;
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
  return value;
}
inline void Alert::clear_url() {
  if (_impl_.url_ != nullptr) _impl_.url_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_url() const {
  const ::transit_realtime::TranslatedString* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::url() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.url)
  return _internal_url();
}
inline void Alert::unsafe_arena_set_allocated_url(
    ::transit_realtime::TranslatedString* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = url;
  if (url) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.url)
}
inline ::transit_realtime::TranslatedString* Alert::release_url() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.url)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.url_ = p;
  }
  return _impl_.url_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.url)
  return _msg;
}
inline void Alert::set_allocated_url(::transit_realtime::TranslatedString* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_ = url;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.url)
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::has_header_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_text_ != nullptr);
  return value;
}
inline void Alert::clear_header_text() {
  if (_impl_.header_text_ != nullptr) _impl_.header_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_header_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.header_text)
  return _internal_header_text();
}
inline void Alert::unsafe_arena_set_allocated_header_text(
    ::transit_realtime::TranslatedString* header_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_text_);
  }
  _impl_.header_text_ = header_text;
  if (header_text) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.header_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_header_text() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_header_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.header_text)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_header_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.header_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.header_text_ = p;
  }
  return _impl_.header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_header_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.header_text)
  return _msg;
}
inline void Alert::set_allocated_header_text(::transit_realtime::TranslatedString* header_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_text_;
  }
  if (header_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header_text);
    if (message_arena != submessage_arena) {
      header_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_text_ = header_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.header_text)
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::has_description_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_text_ != nullptr);
  return value;
}
inline void Alert::clear_description_text() {
  if (_impl_.description_text_ != nullptr) _impl_.description_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_description_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.description_text)
  return _internal_description_text();
}
inline void Alert::unsafe_arena_set_allocated_description_text(
    ::transit_realtime::TranslatedString* description_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_text_);
  }
  _impl_.description_text_ = description_text;
  if (description_text) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.description_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_description_text() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_description_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.description_text)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_description_text() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.description_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.description_text_ = p;
  }
  return _impl_.description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_description_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.description_text)
  return _msg;
}
inline void Alert::set_allocated_description_text(::transit_realtime::TranslatedString* description_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_text_;
  }
  if (description_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description_text);
    if (message_arena != submessage_arena) {
      description_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_text_ = description_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.description_text)
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TimeRange::clear_start() {
  _impl_.start_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::set_start(::uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.start)
}
inline ::uint64_t TimeRange::_internal_start() const {
  return _impl_.start_;
}
inline void TimeRange::_internal_set_start(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}

// optional uint64 end = 2;
inline bool TimeRange::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TimeRange::clear_end() {
  _impl_.end_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::set_end(::uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.end)
}
inline ::uint64_t TimeRange::_internal_end() const {
  return _impl_.end_;
}
inline void TimeRange::_internal_set_end(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Position::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.latitude)
  return _internal_latitude();
}
inline void Position::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.latitude)
}
inline float Position::_internal_latitude() const {
  return _impl_.latitude_;
}
inline void Position::_internal_set_latitude(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latitude_ = value;
}

// required float longitude = 2;
inline bool Position::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Position::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.longitude)
  return _internal_longitude();
}
inline void Position::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.longitude)
}
inline float Position::_internal_longitude() const {
  return _impl_.longitude_;
}
inline void Position::_internal_set_longitude(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.longitude_ = value;
}

// optional float bearing = 3;
inline bool Position::has_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Position::clear_bearing() {
  _impl_.bearing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Position::bearing() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.bearing)
  return _internal_bearing();
}
inline void Position::set_bearing(float value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.bearing)
}
inline float Position::_internal_bearing() const {
  return _impl_.bearing_;
}
inline void Position::_internal_set_bearing(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bearing_ = value;
}

// optional double odometer = 4;
inline bool Position::has_odometer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Position::clear_odometer() {
  _impl_.odometer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Position::odometer() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.odometer)
  return _internal_odometer();
}
inline void Position::set_odometer(double value) {
  _internal_set_odometer(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.odometer)
}
inline double Position::_internal_odometer() const {
  return _impl_.odometer_;
}
inline void Position::_internal_set_odometer(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.odometer_ = value;
}

// optional float speed = 5;
inline bool Position::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Position::clear_speed() {
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.speed)
  return _internal_speed();
}
inline void Position::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.speed)
}
inline float Position::_internal_speed() const {
  return _impl_.speed_;
}
inline void Position::_internal_set_speed(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::has_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripDescriptor::clear_trip_id() {
  _impl_.trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripDescriptor::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.trip_id)
  return _internal_trip_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_trip_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.trip_id)
}
inline std::string* TripDescriptor::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.trip_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_trip_id() const {
  return _impl_.trip_id_.Get();
}
inline void TripDescriptor::_internal_set_trip_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_trip_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trip_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.trip_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.trip_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TripDescriptor::set_allocated_trip_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trip_id_.IsDefault()) {
          _impl_.trip_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.trip_id)
}

// optional string route_id = 5;
inline bool TripDescriptor::has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripDescriptor::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripDescriptor::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.route_id)
  return _internal_route_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_route_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.route_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.route_id)
}
inline std::string* TripDescriptor::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.route_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void TripDescriptor::_internal_set_route_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_route_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.route_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.route_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.route_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TripDescriptor::set_allocated_route_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.route_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.route_id_.IsDefault()) {
          _impl_.route_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.route_id)
}

// optional uint32 direction_id = 6;
inline bool TripDescriptor::has_direction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TripDescriptor::clear_direction_id() {
  _impl_.direction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t TripDescriptor::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.direction_id)
  return _internal_direction_id();
}
inline void TripDescriptor::set_direction_id(::uint32_t value) {
  _internal_set_direction_id(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.direction_id)
}
inline ::uint32_t TripDescriptor::_internal_direction_id() const {
  return _impl_.direction_id_;
}
inline void TripDescriptor::_internal_set_direction_id(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.direction_id_ = value;
}

// optional string start_time = 2;
inline bool TripDescriptor::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripDescriptor::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripDescriptor::start_time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_time)
}
inline std::string* TripDescriptor::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_time)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void TripDescriptor::_internal_set_start_time(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.start_time_.Mutable( GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_time() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_time)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.start_time_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TripDescriptor::set_allocated_start_time(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_time_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_time_.IsDefault()) {
          _impl_.start_time_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_time)
}

// optional string start_date = 3;
inline bool TripDescriptor::has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripDescriptor::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripDescriptor::start_date() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_date)
}
inline std::string* TripDescriptor::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_date)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_date() const {
  return _impl_.start_date_.Get();
}
inline void TripDescriptor::_internal_set_start_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_date() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_date_.Mutable( GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_date() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_date)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.start_date_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TripDescriptor::set_allocated_start_date(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_date_.IsDefault()) {
          _impl_.start_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_date)
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TripDescriptor::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
   _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.schedule_relationship)
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::_internal_schedule_relationship() const {
  return static_cast<::transit_realtime::TripDescriptor_ScheduleRelationship>(_impl_.schedule_relationship_);
}
inline void TripDescriptor::_internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  assert(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleDescriptor::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.id)
}
inline std::string* VehicleDescriptor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.id)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VehicleDescriptor::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleDescriptor::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.id)
}

// optional string label = 2;
inline bool VehicleDescriptor::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleDescriptor::label() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_label(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.label)
}
inline std::string* VehicleDescriptor::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.label)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_label() const {
  return _impl_.label_.Get();
}
inline void VehicleDescriptor::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_label() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.label)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.label_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleDescriptor::set_allocated_label(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.label)
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::has_license_plate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_license_plate() {
  _impl_.license_plate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VehicleDescriptor::license_plate() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.license_plate)
  return _internal_license_plate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_license_plate(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.license_plate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.license_plate)
}
inline std::string* VehicleDescriptor::mutable_license_plate() {
  std::string* _s = _internal_mutable_license_plate();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.license_plate)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_license_plate() const {
  return _impl_.license_plate_.Get();
}
inline void VehicleDescriptor::_internal_set_license_plate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.license_plate_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_license_plate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.license_plate_.Mutable( GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_license_plate() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.license_plate)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.license_plate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.license_plate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void VehicleDescriptor::set_allocated_license_plate(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.license_plate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.license_plate_.IsDefault()) {
          _impl_.license_plate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.license_plate)
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::has_agency_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EntitySelector::clear_agency_id() {
  _impl_.agency_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntitySelector::agency_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.agency_id)
  return _internal_agency_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_agency_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.agency_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.agency_id)
}
inline std::string* EntitySelector::mutable_agency_id() {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.agency_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_agency_id() const {
  return _impl_.agency_id_.Get();
}
inline void EntitySelector::_internal_set_agency_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.agency_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_agency_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.agency_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EntitySelector::release_agency_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.agency_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.agency_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.agency_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EntitySelector::set_allocated_agency_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.agency_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.agency_id_.IsDefault()) {
          _impl_.agency_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.agency_id)
}

// optional string route_id = 2;
inline bool EntitySelector::has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EntitySelector::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EntitySelector::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_id)
  return _internal_route_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_route_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.route_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_id)
}
inline std::string* EntitySelector::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.route_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void EntitySelector::_internal_set_route_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_route_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.route_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EntitySelector::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.route_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.route_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EntitySelector::set_allocated_route_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.route_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.route_id_.IsDefault()) {
          _impl_.route_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.route_id)
}

// optional int32 route_type = 3;
inline bool EntitySelector::has_route_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void EntitySelector::clear_route_type() {
  _impl_.route_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t EntitySelector::route_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_type)
  return _internal_route_type();
}
inline void EntitySelector::set_route_type(::int32_t value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_type)
}
inline ::int32_t EntitySelector::_internal_route_type() const {
  return _impl_.route_type_;
}
inline void EntitySelector::_internal_set_route_type(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.route_type_ = value;
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void EntitySelector::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.trip)
  return _internal_trip();
}
inline void EntitySelector::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.EntitySelector.trip)
}
inline ::transit_realtime::TripDescriptor* EntitySelector::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.trip)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.trip)
  return _msg;
}
inline void EntitySelector::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.trip)
}

// optional string stop_id = 5;
inline bool EntitySelector::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EntitySelector::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EntitySelector::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.stop_id)
}
inline std::string* EntitySelector::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.stop_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void EntitySelector::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stop_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EntitySelector::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.stop_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EntitySelector::set_allocated_stop_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stop_id_.IsDefault()) {
          _impl_.stop_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.stop_id)
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TranslatedString_Translation::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranslatedString_Translation::text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedString_Translation::set_text(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.text)
}
inline std::string* TranslatedString_Translation::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.text)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranslatedString_Translation::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TranslatedString_Translation::set_allocated_text(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.text)
}

// optional string language = 2;
inline bool TranslatedString_Translation::has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TranslatedString_Translation::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranslatedString_Translation::language() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedString_Translation::set_language(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.language)
}
inline std::string* TranslatedString_Translation::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.language)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranslatedString_Translation::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable( GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_language() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.language)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.language_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TranslatedString_Translation::set_allocated_language(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_.IsDefault()) {
          _impl_.language_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.language)
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::_internal_translation_size() const {
  return _impl_.translation_.size();
}
inline int TranslatedString::translation_size() const {
  return _internal_translation_size();
}
inline void TranslatedString::clear_translation() {
  _internal_mutable_translation()->Clear();
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.translation)
  return _internal_mutable_translation()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedString.translation)
  return _internal_mutable_translation();
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::_internal_translation(int index) const {
  return _internal_translation().Get(index);
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.translation)
  return _internal_translation(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::_internal_add_translation() {
  return _internal_mutable_translation()->Add();
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() {
  ::transit_realtime::TranslatedString_Translation* _add = _internal_add_translation();
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedString.translation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
TranslatedString::translation() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedString.translation)
  return _internal_translation();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>&
TranslatedString::_internal_translation() const {
  return _impl_.translation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>*
TranslatedString::_internal_mutable_translation() {
  return &_impl_.translation_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace transit_realtime


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::transit_realtime::FeedHeader_Incrementality> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::FeedHeader_Incrementality>() {
  return ::transit_realtime::FeedHeader_Incrementality_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_VehicleStopStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_VehicleStopStatus>() {
  return ::transit_realtime::VehiclePosition_VehicleStopStatus_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_CongestionLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_CongestionLevel>() {
  return ::transit_realtime::VehiclePosition_CongestionLevel_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_OccupancyStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_OccupancyStatus>() {
  return ::transit_realtime::VehiclePosition_OccupancyStatus_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Alert_Cause> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Alert_Cause>() {
  return ::transit_realtime::Alert_Cause_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Alert_Effect> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Alert_Effect>() {
  return ::transit_realtime::Alert_Effect_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::TripDescriptor_ScheduleRelationship> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::TripDescriptor_ScheduleRelationship>() {
  return ::transit_realtime::TripDescriptor_ScheduleRelationship_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto_2epb_2eh
